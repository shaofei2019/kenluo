<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言中float类型的取值范围</title>
    <url>/archives/eedadecf.html</url>
    <content><![CDATA[<h2 id="一-float类型的取值范围"><a href="#一-float类型的取值范围" class="headerlink" title="一. float类型的取值范围"></a>一. float类型的取值范围</h2><p>范    围 [-3.4E+38,3.4E+38]</p>
<h2 id="二-计算方法-前置概念"><a href="#二-计算方法-前置概念" class="headerlink" title="二. 计算方法: 前置概念"></a>二. 计算方法: 前置概念</h2><p>接下来会详细介绍这个范围是怎么计算出来的, 不过在介绍具体的计算方法前, 必须先了解一些概念. 只有了解了这些概念, 才能真正的理解浮点数的取值范围是如何计算出来的. 而理解这些概念之前, 请务必确定你已经对IEEE754的基础概念和浮点数在内存中的存储方式有所了解, 也可以参考本系列的第一篇文章: <a href="https://www.scanf.top/cnotes/80.html" target="_blank" rel="noopener external nofollow noreferrer">C语言中float类型的存储方式</a></p>
<h3 id="概念一-subnormal-number"><a href="#概念一-subnormal-number" class="headerlink" title="概念一: subnormal number"></a>概念一: subnormal number</h3><p>根据IEEE754的规定, 按照尾数位隐藏的整数部分是1.还是0. 可以将浮点数划分为两类 下面以32位浮点数为例来解释这些概念. <strong>normal number:</strong> 尾数位隐藏的整数部分是<strong>1.</strong>的数, 叫做normal number, 即正常的数 一般来说, 我们遇到的都是normal number 比如20.5在内存中表示为: 0  1000 0011  <strong>0100 1000 0000 0000 000</strong> 其中尾数部分(即上面的加粗部分), 去掉后面补的零之后为: 01001 这其实表示尾数是: 1.01001, 因为前面省略了整数部分1. <strong>subnormal number:</strong> 尾数位隐藏的整数部分为<strong>0.</strong>的数, 叫做sunormal number, 也叫作denormal number, 即低于正常的数 之所以引入subnormal number这个概念, 是为了在浮点数下溢时, 可以逐位的损失精度, 以尽可能精确的表达0附近的极小数(如0.0000001) 为了表示subnormal number, IEEE754规定: <strong>如果将指数位全部填充为0, 则表示这个数是个subnormal number</strong> 即以32位float为例, 当你看到类似于 * <strong>00000000</strong> *********************** 这样内存状态的数时, (即指数位全部为0的数), 就应该知道, 这是个subnormal number, 此时这个数的尾数位隐藏的整数不是<strong>1.</strong>  而是<strong>0.</strong></p>
<h3 id="概念二-non-number"><a href="#概念二-non-number" class="headerlink" title="概念二: non-number"></a>概念二: non-number</h3><p>和subnormal number类似, IEEE754对于指数位全为1的状态也做了特殊规定: <strong>当指数位全部被1填充, 即指数位表示的值为255时, 用于表示这个浮点数处在一种非正常数(non-number)的状态: 即这个数可能是±infinity或NaN.</strong> (Infinity和NaN是两个特殊值, 分别表示无穷和Not a Number)</p>
<blockquote>
<p>The biased-exponent field is filled with all 1 bits to indicate either infinity or an invalid result of a computation.</p>
</blockquote>
<h2 id="三-计算方法"><a href="#三-计算方法" class="headerlink" title="三. 计算方法"></a>三. 计算方法</h2><p>在了解了上面两个概念之后, 再看计算方法就很简单了. 如上所述, IEEE754规定, 当指数位全部为0或者全部为1时, 用于表示两种特殊状态的数: subnormal number 和 non-number, 所以现在可以得到如下示意图, 以32位单精度浮点数为例:</p>
<p><img src="https://www.scanf.top/wp-content/uploads/2019/07/3856786-cdff01ea6080e00b.png" alt=""></p>
<p>这就是理解单精度浮点数取值范围的关键: <strong>当我们讨论浮点数的取值范围时, 实际上讨论的是:</strong> <strong>normal number (上图中绿色部分)的范围.</strong> 可以看出, 32位浮点数的指数其实是无法取到-127和128的, 因为用于表示-127的0000 0000被用来表示subnormal number了, 而用于表示128的1111 1111被用来表示non-number了. <strong>所以实际上32位浮点数的指数部分只能取到只能取到[-126, 127]</strong> 下面来看看尾数: 对于normal number, 尾数前隐藏的整数部分始终保持1. 所以尾数(含隐藏的整数部分)表示值的范围其实是 [1.00…00, 1.11…11], 这个二进制数, 约等于十进制的[1, 2), 因为1.11..11非常逼近十进制的2 好啦, 现在我们知道, 对于32位flaot而言: 尾数(含隐藏的整数部分)的可取值为: [1 ,2), 指数位可取值[-126, 127] 且浮点数可正可负, 所以32位float的取值范围是: [-2*2^127,2*2^127] 约等于: [-3.4*10^38, 3.4 * 10^38] 浮点数的取值范围即这样计算出来的.</p>
]]></content>
      <tags>
        <tag>C/C++笔记</tag>
        <tag>float</tag>
      </tags>
  </entry>
  <entry>
    <title>C编译器如何读取并确定一个符号？</title>
    <url>/archives/99ae3ea5.html</url>
    <content><![CDATA[<p><strong>读取规则：每一个符号应该包含尽可能多的字符。</strong> 编译器读取符号的方法是，从左到右一个字符一个字符地读入，如果该字符可能组成一个符号，那么再读入下一个字符，判断已经读取的两个字符组成的字符串是否可能是一个符号的组成部分；如果可能，继续读入下一个字符，重复上述判断，直到读入的字符组成的字符串已不再可能组成一个有意义的符号。这个处理策略又是被称为“贪心法”。</p>
<h4 id="分析：a-b"><a href="#分析：a-b" class="headerlink" title="分析：a- - -b;"></a><strong>分析：a- - -b;</strong></h4><p>编译器读取到第二个减号字符的时候判断“–”是否能组成一个符号，结果当然是可以的，编译器继续读取下一个字符‘-’，判断“_- - -_”能否组成一个符号？不能，那么<strong>a- - -b</strong>的含义是：<strong>a - -   - b</strong>，注意中减号中间的空格。</p>
<h4 id="分析：y-x-p-p指向除数"><a href="#分析：y-x-p-p指向除数" class="headerlink" title="分析：y = x/*p;       /* p指向除数 */"></a><strong>分析：y = x/*p;       /* p指向除数 */</strong></h4><p>我们能看出该语句的本意似乎是x除以p所指向的值，所得的商赋值给变量y；而实际上编译器会把/*当作一段注释的开始。所以编译器不会理会/*后的代码。尽管你不小心写出了这样的代码，你应该会及时发现出问题了，因为至少编译时编译器会告诉你缺少句末的分号。这时只需要在/和*之间敲个空格就行了。</p>
<blockquote>
<p>整理自：《C Traps and Pitfalls》</p>
</blockquote>
]]></content>
      <tags>
        <tag>C/C++笔记</tag>
        <tag>贪心法</tag>
      </tags>
  </entry>
  <entry>
    <title>*.c到*.exe经历了什么</title>
    <url>/archives/78338158.html</url>
    <content><![CDATA[<p>“*.c”是一个由C语言编程的源代码文件，“*.exe”是一个可执行文件。 .c到.exe经历了什么？阅读下图可知一二。 <img src="https://www.scanf.top/wp-content/uploads/2019/07/img-300x273.jpg" alt=""></p>
<blockquote>
<p>编译器：能将高级语言装换成计算机能理解的低级语言。 链接器：能把目标代码、系统的启动代码和库代码这三部分合成一个文件，即可执行文件。</p>
</blockquote>
<p>对于库代码（c编程中经常用到的scanf（）等函数就包含其中），链接器只会把程序中要用到的库代码函数提取出来。另外，目标文件和可执行文件都由机器语言指令组成。</p>
<blockquote>
<p>文中图1.4来自《 C primer plus 第六版》</p>
</blockquote>
]]></content>
      <tags>
        <tag>C/C++笔记</tag>
        <tag>可执行文件</tag>
        <tag>库代码</tag>
        <tag>链接器</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言中float类型的存储方式</title>
    <url>/archives/1b55ca1d.html</url>
    <content><![CDATA[<h3 id="float类型在内存中的存储方式："><a href="#float类型在内存中的存储方式：" class="headerlink" title="float类型在内存中的存储方式："></a>float类型在内存中的存储方式：</h3><p>IEEE754标准提供了如何在计算机内存中, <strong>以二进制的方式存储十进制浮点数</strong>的具体标准, 这里以float类型(即32位单精度类型)为例, 这是其在内存中存储方式的示意图:</p>
<p><img src="https://www.scanf.top/wp-content/uploads/2019/07/3856786-ae03d5bf85464324.png" alt=""></p>
<p>用float类型存储一个十进制的浮点数, 共需要32个二进制内存位(对应到图中就是32个方块). 二进制内存位编号从高到低 (从31到0), 包含如下几个部分: <strong>sign: 符号位, 即图中蓝色的方块</strong> <strong>biased exponent: 偏移后的指数位, 即图中绿色的方块</strong> <strong>fraction: 尾数位, 即图中红色的方块</strong> 下面会依次介绍这三个概念。</p>
<h3 id="一、符号位-sign"><a href="#一、符号位-sign" class="headerlink" title="一、符号位: sign"></a>一、符号位: sign</h3><p>以float类型 (即32位单精度类型, 以下不再赘述) 为例: 符号位: 占据最高位(第31位)这一位, 用于表示这个浮点数是正数还是负数, 为0表示正数, 为1表示负数. 举例: 对于十进制数20.5, 存储在内存中时, 符号位为0, 因为这是个正数</p>
<h3 id="二、偏移后的指数位-biased-exponent"><a href="#二、偏移后的指数位-biased-exponent" class="headerlink" title="二、偏移后的指数位: biased exponent"></a><strong>二、偏移后的指数位: biased exponent</strong></h3><p>以float类型为例: 指数位: 占据第30位到第23位这8位. 用于表示以2位底的指数. 至于这个指数的作用, 下文会详细讲解, 这里只需要知道: 8位二进制可以表示256种状态, <strong>IEEE754规定, 指数位用于表示[-127, 128]范围内的指数</strong>. 不过为了表示起来更方便, 浮点型的指数位都有一个固定的<strong>偏移量(bias)</strong>, 来使指数位变为<strong>非负整数</strong>. 这样指数部分就不用为如何表示负数而担心了. <strong>规定: 在32位单精度类型中, 这个偏移量是127. 在64位双精度类型中, 偏移量是1023.</strong> 所以这里偏移量是127, 即如果你运算后得到的指数是 -127, 那么偏移后, 在指数位中需要表示为: -127 + 127(偏移量) = 0 如果你运算后得到的指数是 -10, 那么偏移后, 在指数位中需要表示为: -10 + 127(偏移量) = 117 看, 有了偏移量, 指数位就始终是一个非负整数了. 看到这里, 可能会觉得还不是很清楚指数的作用到的是什么. 没关系, 让我们先继续往下看吧…</p>
<h3 id="三、尾数位-fraction"><a href="#三、尾数位-fraction" class="headerlink" title="三、尾数位:fraction"></a><strong>三、尾数位:fraction</strong></h3><p>依旧以32位float为例. 尾数位: 占据剩余的22位到0位这23位. 用于存储尾数. 在以二进制格式存储十进制浮点数时, 首先需要把十进制浮点数表示为二进制格式, 还拿十进制数20.5举例: 十进制浮点数20.5 = 二进制10100.1 然后需要把这个二进制数转换为以2为底的指数形式: 二进制10100.1 = <strong>1.01001</strong> * 2^4 注意转换时, 对于乘号左边, 加粗的那个二进制数<strong>1.01001</strong>, 需要把小数点放在左起第一位和第二位之间. 且第一位需要是个非0数. 这样表示好之后, 其中的<strong>1.01001</strong>就是<strong>尾数.</strong> 这种用二进制表示十进制浮点数, 表示为<strong>尾数*指数</strong>形式, 把尾数的小数点放在第一位和第二位之间, 然后保证第一位数非0的处理过程, 叫做<strong>规范化(normalized)</strong> 我们再来看看规范化之后的这个数: 1.01001 * 2^4 其中1.01001是尾数,  而4就是<strong>偏移前的指数(unbiased exponent)</strong>, 上文讲过, 32位float类型, 偏移量(bias)为127, 所以这里加上偏移量之后, 得到的<strong>偏移后指数(biased exponent)</strong>就是4 + 127 = 131, 131转换为二进制就是1000 0011 现在还需要对尾数做一些特殊处理</p>
<h4 id="1-隐藏高位1"><a href="#1-隐藏高位1" class="headerlink" title="1. 隐藏高位1"></a>1. 隐藏高位1</h4><p>你会发现, 尾数部分的最高位始终为1. 比如这里的 1.01001, 这是因为前面说过, 规范化之后, 尾数中的小数点会位于左起第一位和第二位之间. 且第一位是个非0数. 而二进制中, 每一位可取值只有0或1, 如果第一位非0, 则第一位只能为1. 所以在存储尾数时, 可以省略前面的 1和小数点. 只记录尾数中小数点之后的部分, 这样就节约了一位内存. 所以这里只需记录剩余的尾数部分: 01001 所以, 以后再提到尾数, 如无特殊说明, 指的其实是隐藏了整数部分1. 之后, 剩下的小数部分</p>
<h4 id="2-低位补0"><a href="#2-低位补0" class="headerlink" title="2. 低位补0"></a>2. 低位补0</h4><p>如果尾数不够填满尾数位(即图中的红色部分). 比如这里的, 尾数不够23位, 则在低位补零, 补齐23位. 之所以在低位补0, 是因为尾数中存储的本质上是二进制的小数部分, 所以如果想要在不影响原数值的情况下, 填满23位, 就需要在低位补零 例如,  把二进制数1.01在不改变原值的情况下填满八位内存, 写出来就是: 1.010 0000, 即需要在低位补0 题外话: 如果尾数位置存储的是整数部分(而非小数部分), 想要在不影响原数值的情况下补齐n位, 就需要在高位补0了, 例如. 把二进制数10在不改变原值的情况下填满八位内存, 写出来就是: 0000 0010, 即需要在高位补0 因为尾数部分存储的本质上是省略了1.之后的小数部分, 所以这里需要低位补0, 原尾数是01001: 补零之后是 0100 1000 0000 0000 000</p>
<h3 id="表示十进制浮点数20-5"><a href="#表示十进制浮点数20-5" class="headerlink" title="表示十进制浮点数20.5"></a>表示十进制浮点数20.5</h3><p>在上面的讨论中, 已经得出 十进制20.5的符号位: 0 偏移后指数位: 1000 0011 补零后尾数位: 0100 1000 0000 0000 000 按顺序放在32位float容器中, 就是 0    1000 0011    0100 1000 0000 0000 000 这就在32位内存中, 以二进制表示了一个十进制数20.5的方式。</p>
<h3 id="为了加深理解-我们再反向推导一遍"><a href="#为了加深理解-我们再反向推导一遍" class="headerlink" title="为了加深理解, 我们再反向推导一遍:"></a>为了加深理解, 我们再反向推导一遍:</h3><p>假设现在我们有一个用二进制表示的32位浮点数: 0   1000 0011   0100 1000 0000 0000 000, 求它表示的十进制浮点数是多少? 观察可知: 符号位为0: 所以这是个正数. 尾数是: 0100 1000 0000 0000 000去掉后面的补零, 再加上隐藏的整数部分1. 得到完整的尾数(含隐藏的整数部分)为: 1.01001 偏移后的指数位为: 1000 0011, 转换为十进制为131, 减去偏移量127, 得4 所以, 最后得到的浮点数 = 尾数(含隐藏的整数部分) * 以2为底的指数次幂 =  二进制的: 1.01001 * 2^4 =  把小数点向右移动4位 =  二进制的10100.1 =十进制2^4+2^2+2^-1 =  十进制位20.5</p>
<h4 id="随后是一张大体的计算方法示意图："><a href="#随后是一张大体的计算方法示意图：" class="headerlink" title="随后是一张大体的计算方法示意图："></a>随后是一张大体的计算方法示意图：</h4><p><img src="https://www.scanf.top/wp-content/uploads/2019/07/3856786-d1dc6bba880596ef-300x93.png" alt=""></p>
<blockquote>
<p>本文转载于：<a href="https://www.jianshu.com/p/8ee02e9bb57d" target="_blank" rel="noopener external nofollow noreferrer">https://www.jianshu.com/p/8ee02e9bb57d</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>C/C++笔记</tag>
        <tag>float</tag>
        <tag>指数偏移</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言中int类型的取值范围</title>
    <url>/archives/f096cc51.html</url>
    <content><![CDATA[<p>在<a href="https://www.scanf.top/cnotes/48.html" target="_blank" rel="noopener external nofollow noreferrer">C语言</a>中，int表示整型变量，是一种数据类型，用于定义一个整型变量。 C语言中int能定义的整数的取值范围为：[-2147483648,2147483647]</p>
<h4 id="解释如下："><a href="#解释如下：" class="headerlink" title="解释如下："></a>解释如下：</h4><p>int类型在C语言中占4个字节，即32个二进制位。 ①：当表示正数时，最高位为符号位（符号位为0），int所能定义的最大的正数的原码是： 0111 1111 1111 1111 1111 1111 1111 1111即2^31 -1 = 2147483647。 ②：当表示负数时，最高位为符号位（符号位为1），<strong>需要知道在计算机系统中，数值一律用补码来表示和存储</strong>。查询相关资料得知int所能定义的最小的负数的原码和补码均为 ：1000 0000 0000 0000 0000 0000 0000 0000。 即-2^31=-2147483648</p>
<blockquote>
<p>•负数的反码是在其原码的基础上，符号位（首位）不变，其余各个位取反 •负数的补码是在其反码的基础上加1 •正数的原码==反码==补码</p>
</blockquote>
<p>所以C语言中<a href="https://baike.baidu.com/item/int%E5%87%BD%E6%95%B0/3433643" target="_blank" rel="noopener external nofollow noreferrer">int</a>的取值范围为：[-2147483648,2147483647]</p>
]]></content>
      <tags>
        <tag>C/C++笔记</tag>
        <tag>int</tag>
      </tags>
  </entry>
  <entry>
    <title>printf和scanf的返回值</title>
    <url>/archives/4d4f4d70.html</url>
    <content><![CDATA[<p>printf的返回值是待显示字符的个数。编译运行如下代码验证，最终num=5</p>
<p>#include &lt;stdio.h&gt;</p>
<p>int main(void)<br>{<br>    int num;</p>
<pre><code>num=printf(&quot;china&quot;);
printf(&quot;\\n%d&quot;,num);

return 0;</code></pre><p>}</p>
<p>scanf的返回值，当scanf函数第一个变量格式不正确时返回0，即当scanf函数的第n个变量格式不正确时，返回值为n-1。如果scanf读取的数据类型都与转换说明，此时scanf的返回值为所读取变量的个数。</p>
<p>#include &lt;stdio.h&gt;</p>
<p>int main(void)<br>{<br>    int num,a,b;</p>
<pre><code>num=scanf(&quot;%d %d&quot;,&amp;a,&amp;b);
printf(&quot;return of scanf:%d\\na=%d b=%d&quot;,num,a,b); 

return 0;</code></pre><p>}</p>
<p>编译运行， 按顺序输入1和2，num=2 按顺序输入1和a，num=1 按顺序输入a和1，num=0</p>
]]></content>
      <tags>
        <tag>C/C++笔记</tag>
        <tag>printf</tag>
        <tag>scanf</tag>
      </tags>
  </entry>
  <entry>
    <title>main()的参数argc和argv</title>
    <url>/archives/ef3944df.html</url>
    <content><![CDATA[<h3 id="源代码："><a href="#源代码：" class="headerlink" title="源代码："></a>源代码：</h3><p>#include &lt;stdio.h&gt;<br>int main ( int argc, char *argv [] )<br>{<br>  printf(“argv[0]:%s\n”,argv[0]);<br>  printf(“argv[1]:%s\n”,argv[1]);<br>  printf(“argv[2]:%s\n”,argv[2]);<br>  printf(“argv[3]:%s\n”,argv[3]);<br>  printf(“一共有：%d个命令行参数”,argc);</p>
<p>  return 0;<br>}</p>
<h3 id="测试结果："><a href="#测试结果：" class="headerlink" title="测试结果："></a>测试结果：</h3><p><img src="https://scanf.top/wp-content/uploads/2019/10/6203d7a613c7af69fac8a42f21ed4d6f.png" alt=""></p>
<h3 id="相关说明："><a href="#相关说明：" class="headerlink" title="相关说明："></a>相关说明：</h3><p>argc：为命令行总的参数的个数 *argv[ ]：字符串数组，用来存放指向你的字符串参数的指针数组,每一个元素指向一个参数。 argv[0]:指向程序的全路径名 argv[1]:指向在DOS命令行中执行程序名后的第一个字符串 argv[2]:指向在DOS命令行中执行程序名后的第二个字符串 argv[3]:指向在DOS命令行中执行程序名后的第三个字符串</p>
]]></content>
      <tags>
        <tag>C/C++笔记</tag>
        <tag>argc</tag>
        <tag>argv</tag>
      </tags>
  </entry>
  <entry>
    <title>i++和++i的区别</title>
    <url>/archives/8fda38dd.html</url>
    <content><![CDATA[<p>i++和++i是C语言运算符，i++是后缀递增的意思，++i是前缀递增的意思。 1、i++是后缀递增的意思，i++是先进行表达式运算，再进行自增运算。把i++的运算过程拆分开，等效于i=i+1可以看到运算结果是一致的。 x = i ++;    //先让x变成i的值，再让i加1 2、++i是前缀递增的意思，++i是先进行自增或者自减运算，再进行表达式运算。运算结果可以发现，仅从i的值来看，++i和i++最终的i值是一样的，都是i自增加了1。 x = ++i;    //先让i加1, 再让x变成i+1之后的值  </p>
<p>#include &lt;stdio.h&gt;</p>
<p>int main(void)<br>{<br>    int a_post=0,b_pre=0,i=1,o=1;</p>
<pre><code>a\_post = i++;//先赋值再运算
b\_pre  = ++o;//先运算再赋值
printf(&quot;a\_post=%d,b\_pre=%d\\ni=%d,o=%d&quot;,a\_post,b\_pre,i,o);

return 0;</code></pre><p>}</p>
<p>而使用递减运算符 - - ，要达到相应的效果，直接代替++即可。</p>
]]></content>
      <tags>
        <tag>C/C++笔记</tag>
        <tag>递增运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言的术语：数据对象、左值</title>
    <url>/archives/2456e15a.html</url>
    <content><![CDATA[<p>用于储存值的数据区域统称为<strong>数据对象（</strong><em>data object</em><strong>）。</strong> <strong>左值</strong>（_lvalue_）是C语言的术语，用于标识特定数据对象的名称或表达式。   对象指的是实际的数据存储，而左值是用于标识或定位存储位置的标签。</p>
]]></content>
      <tags>
        <tag>C/C++笔记</tag>
        <tag>左值</tag>
        <tag>数据对象</tag>
      </tags>
  </entry>
  <entry>
    <title>printf和scanf转换说明中*用法的差异</title>
    <url>/archives/f98a7ee3.html</url>
    <content><![CDATA[<p>printf和scanf中*修饰符的用法含义不同，首先我们来看一下printf的*修饰符。 在<a href="https://www.scanf.top/cnotes/95.html" target="_blank" rel="noopener external nofollow noreferrer">printf</a>中，如果你不想在程序中预设字段宽度，希望通过用户来设定，那么可以使用*修饰符代替字段宽度。所以需要一个参数告诉函数，字段宽度是多少。也就是说，如果转换说明是%*d，那么参数列表中需要包含*和d对应的值。这一技巧也适用于指定浮点数的精度和<a href="https://www.scanf.top/cnotes/97.html" target="_blank" rel="noopener external nofollow noreferrer">字段宽度</a>。如下程序演示了相关应用：</p>
<p>/*  *修饰符在整数中的应用  */<br>#include &lt;stdio.h&gt;</p>
<p>int main(void)<br>{<br>    int num,width; </p>
<pre><code>scanf(&quot;%d %d&quot;,&amp;num,&amp;width);
printf(&quot;%0\*d&quot;,width,num);

return 0;</code></pre><p>}</p>
<h4 id="输入输出演示："><a href="#输入输出演示：" class="headerlink" title="输入输出演示："></a>输入输出演示：</h4><p><strong>10 5</strong></p>
<p>00010</p>
<p>/*  *修饰符在浮点数中的应用  */<br>#include &lt;stdio.h&gt;</p>
<p>int main(void)<br>{<br>    int width,precision;<br>    float num;</p>
<pre><code>scanf(&quot;%d %d %f&quot;,&amp;width,&amp;precision,&amp;num);
printf(&quot;%0\*.\*f&quot;,width,precision,num);

return 0;</code></pre><p>}</p>
<h4 id="输入输出演示：-1"><a href="#输入输出演示：-1" class="headerlink" title="输入输出演示："></a>输入输出演示：</h4><p><strong>10 2 12.374</strong></p>
<p>0000012.37</p>
<p><a href="https://www.scanf.top/cnotes/59.html" target="_blank" rel="noopener external nofollow noreferrer">scanf</a>中*的用法与此不同。把*放在%和转换字符之间，会使scanf跳过相应的输出项。示例如下：</p>
<p>#include &lt;stdio.h&gt;</p>
<p>int main(void)<br>{<br>    int num;</p>
<pre><code>scanf(&quot;%\*d %\*d %d&quot;,&amp;num);
printf(&quot;%d&quot;,num); 

return 0;</code></pre><p>}</p>
<p>scanf()中：跳过前两个整数，把第三个整数拷贝给num。</p>
<h4 id="输入输出演示：-2"><a href="#输入输出演示：-2" class="headerlink" title="输入输出演示："></a>输入输出演示：</h4><p><strong>1 2 3</strong></p>
<p>3</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>printf中*修饰符可以灵活的设定输出字符的字段宽度。*修饰符可以使scnaf()跳过相应的输出项，抑制赋值。</p>
]]></content>
      <tags>
        <tag>C/C++笔记</tag>
        <tag>转换说明</tag>
      </tags>
  </entry>
  <entry>
    <title>sizeof和strlen()的区别</title>
    <url>/archives/8d2d04f8.html</url>
    <content><![CDATA[<p>sizeof() 是一种内存容量度量函数，功能是返回一个变量或者类型的大小（以字节为单位）； strlen()所作的仅仅是一个计数器的工作，它从内存的某个位置开始扫描，直到碰到第一个字符串结束符’\0’为止，然后返回计数器值(长度不包含’\0’)。</p>
<h3 id="举例对比："><a href="#举例对比：" class="headerlink" title="举例对比："></a>举例对比：</h3><p>#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br>#define  STRING “<a href="http://www.scanf.top&quot;" target="_blank" rel="noopener external nofollow noreferrer">www.scanf.top&quot;</a></p>
<p>int main(void)<br>{<br>       printf(“sizeof_STRING:%d\n”,sizeof STRING);<br>       printf(“strlen_STRING:%d”,strlen(STRING));</p>
<pre><code>return 0;</code></pre><p>}</p>
<p>可STRING字符串被储存在char类型的数组中，这个数组有14个存储单元，分别被13个字符和末尾的1个空字符占用。 程序编译运行输出的结果是：</p>
<p>sizeof_STRING:14<br>strlen_STRING:13</p>
]]></content>
      <tags>
        <tag>C/C++笔记</tag>
        <tag>sizeof</tag>
        <tag>strlen()</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】C语言的优点和缺点</title>
    <url>/archives/c756a579.html</url>
    <content><![CDATA[<p>C语言现在已经很成熟，它的各种语法规则、思想都已经确立起来了，并对现在的很多语言产生很大的影响。但是任何事物都有其优点和缺点，C语言也不例外。下面我们分别来看一下。</p>
<h2 id="C语言的优点"><a href="#C语言的优点" class="headerlink" title="C语言的优点"></a>C语言的优点</h2><p>C语言的优点有三个：</p>
<ol>
<li>代码量小。</li>
<li>运行速度快。</li>
<li>功能强大。</li>
</ol>
<p>我们先看第一个优点，C语言的代码量很小，这是什么意思呢？也就是说如果你要完成同样一个功能，用C语言编写出来的程序的容量是很小的，而用其他语言编写容量就会比较大。 比如 Microsoft Word 和 WPS，它们同样都是办公软件，功能也差不多，但 WPS 的安装文件只有 50MB 左右，而 Microsoft Word 的安装文件超过 500MB，有的甚至接近 1GB。原因就是 WPS 的内核是用C语言编写的。 C语言的第二和第三个优点是它的运行速度比较快和功能强大，我们可以通过一个例子来解释。世界上总共有三大操作系统：UNIX 操作系统是用纯C语言编写的；Windows 操作系统的内核也是用C语言编写的；Linux 操作系统仍是用纯C语言编写的。 这三大操作系统的内核全部都是用C语言编写的。为什么用C编写，因为C语言的速度最快。计算机中所有的软件都是在操作系统上运行的，如果操作系统的速度很慢，那么在它基础上运行的软件的速度就更慢了。而且计算机中的所有硬件都是由操作系统控制的。 举个简单的例子，你可以新建一个 Word 文档，这就意味着在硬盘上产生了这个文件。但是你并没有直接控制硬盘，我们是通过操作系统提供的“右键单击”等功能来新建文件的。也就是说，操作系统给我们提供了一个界面，或者说是给我们提供了一种可操作的手段，通过这个手段我们可以删除文件、新建文件、打开文件或者修改文件。 所以操作系统很重要，所有的硬件全部都是由操作系统控制的。而这么重要的东西只能用C语言来写，所以C语言很重要。为什么只能用C语言写？第一，C语言速度够快；第二，C语言可以访问硬件，所以它够强大。 为什么不能用 Java 写？首先，Java 太慢了；其次，Java 语言没有指针。没有指针就不能访问硬件，所以它的功能是不够的。指针是什么稍后会讲，它是C语言中非常重要的内容。</p>
<h2 id="C语言的缺点"><a href="#C语言的缺点" class="headerlink" title="C语言的缺点"></a>C语言的缺点</h2><p>任何语言有优点就有缺点。C语言的缺点可以用下面三点来概括：</p>
<ol>
<li>危险性高。</li>
<li>开发周期长。</li>
<li>可移植性不强。</li>
</ol>
<p>我们先看第一点。假如你写同样一个程序，在 Java 里面会报错，而在C语言里面是不会报错的。为什么？因为C语言设计的思想是：你想怎么写程序就怎么写，只要你的这种写法错得不是很离谱，就认为你这么写有特殊的含义，可以通过。但 Java 不行：只要你这么写有歧义，或者说这样写不太好，那么它都会报错。 比如C语言中你可以将一个浮点型数据赋给一个整型变量，编译时只会警告，因为会丢失精度，但是在 Java 中这样写就会报错，它在语法上就禁止你这样写。所以不同的语言对同样一个问题有不同的处理方式。 大家想想这样导致的结果是什么？因为有歧义的程序也可以通过，这样就会有很多漏洞，黑客往往会抓住这些漏洞进行攻击。所以说C语言比较危险。这也是为什么C语言比较难学的原因，因为你学完之后编写一个程序很可能就是错的，但又很难发现。所以前面说 C++ 从安全性上对C语言进行了升级。 第二个是它的开发周期比较长。因为C语言是面向过程的语言，面向过程语言的一个特点就是写大项目的时候很容易“崩溃”。当代码上到 10 万行的时候很容易崩溃，会出现各种各样莫名其妙的错误。这时候就需要用另外一种思想将整个程序的框架重新设计一下，即用面向对象的思想设计。这也是C语言现在没有 Java 流行的原因。 C语言的第三个缺点是可移植性不强。这个主要是针对 Java 的。Java 的可移植性太强了，所以就显得C语言的可移植性不强。什么叫可移植性？就是说 Java 程序在哪个机器上都可以运行，而且结果一模一样。而C语言就不行，C程序在其他机器上不一定能运行。而且就算能运行，结果可能也不一样。</p>
<blockquote>
<p>本文转载自：C语言中文网 原始链接：<a href="http://c.biancheng.net/view/132.html" target="_blank" rel="noopener external nofollow noreferrer">http://c.biancheng.net/view/132.html</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>C/C++笔记</tag>
        <tag>C语言</tag>
        <tag>c语言优缺点</tag>
      </tags>
  </entry>
  <entry>
    <title>scanf()和scanf_s()的简单区别</title>
    <url>/archives/e698f6a9.html</url>
    <content><![CDATA[<h4 id="简单介绍："><a href="#简单介绍：" class="headerlink" title="简单介绍："></a><strong>简单介绍：</strong></h4><p>scanf()函数是标准C中提供的标准输入函数，用于用户输入数据。 scanf_s()函数是Microsoft公司VS开发工具提供的一个功能相同的安全标准输入函数，从vc++2005开始，VS系统提供了scanf_s()。  </p>
<h4 id="对比区别："><a href="#对比区别：" class="headerlink" title="对比区别："></a><strong>对比区别：</strong></h4><p>scanf()不会检查输入边界，可能造成数据溢出，scanf_s()会进行边界检查。 如name[5]， scanf(“%s”,name),如果输入abcdefgh，则会使得fgh溢出进入其他地方，造成程序错误， 容易被黑客利用；而scanf_s(“%s”,name),则会只会接收前5个输入，其后的无效，避免了程序的漏洞。</p>
]]></content>
      <tags>
        <tag>C/C++笔记</tag>
        <tag>scanf</tag>
        <tag>scanf_s</tag>
      </tags>
  </entry>
  <entry>
    <title>sleep()函数的使用</title>
    <url>/archives/d1b35c7c.html</url>
    <content><![CDATA[<p><a href="https://baike.baidu.com/item/Sleep%E5%87%BD%E6%95%B0/6735027?fr=aladdin" target="_blank" rel="noopener external nofollow noreferrer">Sleep函数</a>可以使计算机程序（进程，任务或线程）进入休眠，使其在一段时间内处于非活动状态。当函数设定的计时器到期，或者接收到信号、程序发生中断都会导致程序继续执行。</p>
<h4 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h4><p>sleep()函数包含在unistd.h头文件中，sleep()函数的<a href="https://www.scanf.top/cnotes/57.html" target="_blank" rel="noopener external nofollow noreferrer">调用</a>需要一个时间作为参数，代表程序执行挂起的时间间隔。通常参数的单位是秒，但在一些更加精确的操作系统中能以毫秒甚至是微秒为单位。</p>
<h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><p>#include&lt;stdio.h&gt;<br>#include &lt;unistd.h&gt;<br>int main(void)<br>{<br>    int buyaoting=1;</p>
<pre><code>printf(&quot;蜂鸣声\\7\\n&quot;);
sleep(2); //等待一秒钟执行下一行代码 
printf(&quot;蜂鸣声\\7\\n&quot;);

return 0;</code></pre><p>}</p>
]]></content>
      <tags>
        <tag>C/C++笔记</tag>
        <tag>sleep()</tag>
      </tags>
  </entry>
  <entry>
    <title>分析printf参数传递的原理</title>
    <url>/archives/87df9351.html</url>
    <content><![CDATA[<blockquote>
<p>printf()函数是格式化输出函数, 一般用于向标准输出设备按规定格式输出</p>
<p>信息。在编写程序时经常会用到此函数。</p>
<p>函数的原型为：</p>
<p>int printf(const char *format, …);</p>
<p><strong>函数返回值为整型。若成功则返回输出的字符数，输出出错则返回负值。</strong></p>
<p>printf()函数的调用格式为:</p>
<p>printf(“&lt;格式化字符串&gt;”, &lt;参量表&gt;);</p>
<p>其中格式化字符串包括两部分内容: 一部分是正常字符, 这些字符将按原</p>
<p>样输出; 另一部分是格式化规定字符, 以”%”开始, 后跟一个或几个规定字符,</p>
<p>用来确定输出内容格式。</p>
<p>参量表是需要输出的一系列参数, 其个数必须与格式化字符串所说明的输出</p>
<p>参数个数一样多, 各参数之间用”,”分开, 且顺序一一对应, 否则将会出现意想</p>
<p>不到的错误。——摘自百度百科《<a href="https://baike.baidu.com/item/printf" target="_blank" rel="noopener external nofollow noreferrer">printf()</a>》</p>
</blockquote>
<h3 id="分析参数传递的原理："><a href="#分析参数传递的原理：" class="headerlink" title="分析参数传递的原理："></a>分析参数传递的原理：</h3><h4 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h4><p>int num=1;<br>printf(“%d”,num);</p>
<p>示例中printf函数的调用告诉计算机把变量num的值传递给程序，程序把传入的值放入被称为栈（<strong>stack</strong>）的内存区域，计算机根据变量类型（int）把该值放入栈中。因此，num被储存在栈中，占4字节。 然后控制转到printf()函数，该函数根据转换说明从栈中读取值。%d转换说明表明printf()应该读取4个字节，所以printf()读取栈中的前四个字节作为值，输出。</p>
]]></content>
      <tags>
        <tag>C/C++笔记</tag>
        <tag>printf</tag>
        <tag>参数传递</tag>
      </tags>
  </entry>
  <entry>
    <title>利用堆栈实现数制转换。</title>
    <url>/archives/4149ca8d.html</url>
    <content><![CDATA[<h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a><strong>算法思想</strong></h3><p>① 定义一个结构体，其中包括栈顶指针、栈底指针和栈的最大可用容量。 ② 初始化一个空栈 Ⅰ.申请一块最大容量为MAXSIZE的数组内存，并将首地址返回给栈底指针。 Ⅱ.将栈设置为空栈，即栈顶指针初始化为栈底指针。 ③ 将处理后的数据压入栈中，判断是否栈满，如果栈满，则返回相应的状态信息；如果栈未满，将数据压入栈中，然后栈顶指针加1. ④ 出栈，判断栈是否为空，如果栈空，则返回相应的状态信息；如果栈非空，栈顶指针减1，再将栈顶元素赋给变量e。</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a><strong>具体实现</strong></h3><p>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt; //提供exit函数<br>#define MAXSIZE 100<br>#define OK 0<br>#define ERROR 1<br>#define OVERFLOW -2</p>
<p>typedef int Status;<br>typedef struct{<br>  int *base;//栈底指针<br>  int *top;//栈顶指针<br>  int stacksize;//栈可用的最大容量<br>}SqStack;<br>Status InitStack ( SqStack &amp;S);//顺序栈的初始化–<br>Status Push ( SqStack &amp;S , int e );//顺序栈的入栈–<br>Status Pop ( SqStack &amp;S , int &amp;e);//顺序栈的出栈–<br>Status StackEmpty( SqStack &amp;S );//判断栈空– </p>
<p>int main ( void )<br>{<br>  int N;<br>  SqStack S;</p>
<p>  InitStack ( S );//初始化空栈<br>  printf( “请输入一个十进制数：” );<br>  scanf( “%d”, &amp;N );<br>  while ( N )<br>  {<br>    Push( S, N % 2 ); //将N除以2的余数压入栈中<br>    N = N / 2; //每次取余后都要更新N的值，供下次取余运算使用<br>  }<br>  while ( !StackEmpty(S) )<br>  {<br>    Pop( S, N );<br>    printf( “%d”, N );<br>  }</p>
<p>  return 0;<br>}</p>
<p>Status InitStack ( SqStack &amp;S )<br>{//顺序栈的初始化<br>  S.base = new int[MAXSIZE];//为顺序栈动态分配一个最大容量为MAXSIZE的数组空间<br>  if(!S.base) exit (OVERFLOW);//存储分配失败<br>  S.top = S.base; //top初始为base,空栈<br>  S.stacksize = MAXSIZE; //stacksize置为栈的最大容量MAXSIEZE </p>
<p>  return OK;<br>}<br>Status Push ( SqStack &amp;S , int e )<br>{//顺序栈的入栈<br>  if( S.top - S.base == S.stacksize ) return ERROR;//栈满<br>  *S.top++ = e;//先压栈，再S.top加1 </p>
<p>  return OK;<br>}<br>Status Pop ( SqStack &amp;S , int &amp;e)<br>{//顺序栈的出栈<br>  if ( S.top == S.base ) return ERROR;//判断是否为空栈<br>  e = *–S.top;//先S.top减1，再将栈顶元素赋给e<br>  *S.top = 0; </p>
<p>  return OK;<br>}<br>Status StackEmpty( SqStack &amp;S )<br>{//判断栈空<br>  if( S.top == S.base ) return ERROR;<br>  else return OK;<br>}</p>
<h3 id="程序演示"><a href="#程序演示" class="headerlink" title="程序演示"></a>程序演示</h3><p><img src="https://scanf.top/wp-content/uploads/2019/12/c1282ed5d73b7d359360daf05afc4b5f.png" alt=""></p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>堆栈</tag>
      </tags>
  </entry>
  <entry>
    <title>利用scanf的返回值控制循环</title>
    <url>/archives/48e7aab4.html</url>
    <content><![CDATA[<p>我们知道，<a href="https://www.scanf.top/cnotes/109.html" target="_blank" rel="noopener external nofollow noreferrer">scanf</a>函数有返回值。我们可以利用scanf的返回值控制while循环。示例如下：</p>
<p>#include&lt;stdio.h&gt;</p>
<p>int main ( void )<br>{<br>    int num,a,b,status;</p>
<pre><code>status=scanf(&quot;%d %d&quot;,&amp;a,&amp;b);//将scanf的返回值赋给status，即scanf读取正确值的个数
while( status &gt;= 2 ){//status大于等于2进入循环
    num=a+b;
    printf(&quot;the sum of %d and %d is %d\\n&quot;,a,b,num);
    status=scanf(&quot;%d %d&quot;,&amp;a,&amp;b); 
} 
printf(&quot;ERROR!&quot;);

return 0;</code></pre><p>}</p>
]]></content>
      <tags>
        <tag>C/C++笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>在创建指针时使用const</title>
    <url>/archives/b7ebd473.html</url>
    <content><![CDATA[<p>//原始<br>#include&lt;stdio.h&gt;<br>int main ( void )<br>{<br>    int rates[5]={1,2,3,4,5};<br>    int * pd =rates;<br>    *pd++;<br>    printf(“%d”,*pd);</p>
<pre><code>return 0;</code></pre><p>}</p>
<p>  我们知道，示例中的pd是一个指针，指向rates首元素的地址，*pd==rates[0]==1。</p>
<h3 id="const用法一："><a href="#const用法一：" class="headerlink" title="const用法一："></a>const用法一：</h3><p>现在希望*pd不被修改，可将原始程序第五行修改如下：</p>
<p>const int * pd =rates;</p>
<p>const的作用，程序执行时将*pd视为一个常量，不可被修改。下面这个程序试图修改*pd，编译器编译时报错：<em>[Error] assignment of read-only location ‘*pd’</em></p>
<p>//编译该程序看看会发生什么<br>#include&lt;stdio.h&gt;<br>int main ( void )<br>{<br>    int rates[5]={1,2,3,4,5};<br>    const int * pd =rates;<br>    *pd=1;<br>    printf(“%d”,*pd);</p>
<pre><code>return 0;</code></pre><p>}</p>
<h3 id="const用法二："><a href="#const用法二：" class="headerlink" title="const用法二："></a>const用法二：</h3><p>现在希望pd（其值为地址）不被修改，修改原始程序如下：</p>
<p>//编译该程序看看会发生什么<br>#include&lt;stdio.h&gt;<br>int main ( void )<br>{<br>    int rates[5]={1,2,3,4,5};<br>    int * const pd =rates;<br>    *pd++;<br>    printf(“%d”,*pd);</p>
<pre><code>return 0;</code></pre><p>}</p>
<p>编译该程序，报错：<em>assignment of read-only location ‘*pd’</em> 要搞清楚为什么报错，需要了解“*pd++”中*和++的优先级，查阅运算符优先级表，发现*和++（运算符后置）优先级相同，但结合方向是从右到左的，所以*pd++等同于*(pd++)。程序视pd为常量，和1++同理，显然不对的。</p>
]]></content>
      <tags>
        <tag>C/C++笔记</tag>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title>取模运算和取余运算的区别</title>
    <url>/archives/8b930033.html</url>
    <content><![CDATA[<p><strong>对于整型数a，b来说，取模运算或者求余运算的方法都是：</strong></p>
<p>1.求 整数商： c = a/b;</p>
<p>2.计算模或者余数： r = a - c*b.</p>
<p>求模运算和求余运算在第一步不同: 取余运算在取c的值时，向0 方向舍入(fix()函数)；而取模运算在计算c的值时，向负无穷方向舍入(floor()函数)。</p>
<p>例如计算：-7 Mod 4</p>
<p>那么：a = -7；b = 4；</p>
<p>第一步：求整数商c，如进行求模运算c = -2（向负无穷方向舍入），求余c = -1（向0方向舍入）；</p>
<p>第二步：计算模和余数的公式相同，但因c的值不同，求模时r = 1，求余时r = -3。</p>
<p>归纳：当a和b符号一致时，求模运算和求余运算所得的c的值一致，因此结果一致。</p>
<p>当符号不一致时，结果不一样。求模运算结果的符号和b一致，求余运算结果的符号和a一致。</p>
<p>另外各个环境下%运算符的含义不同，比如c/c++，java 为取余，而python则为取模。</p>
<blockquote>
<p>本文摘自百度百科:<a href="https://baike.baidu.com/item/取模运算" target="_blank" rel="noopener external nofollow noreferrer">https://baike.baidu.com/item/取模运算</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>java笔记</tag>
        <tag>取余</tag>
        <tag>取模</tag>
      </tags>
  </entry>
  <entry>
    <title>对比while和for循环中的continue语句</title>
    <url>/archives/bd64a196.html</url>
    <content><![CDATA[<p>我们知道，3中循环都可以使用continue语句，执行到该语句时，会跳过本次迭代的剩余部分，并进行下一轮迭代。你应该知道，continue只会影响包含该语句的内层循环，但是continue在while和for中的差别常常被人们忽略。</p>
<h3 id="一、while和do-while中的continue"><a href="#一、while和do-while中的continue" class="headerlink" title="一、while和do while中的continue"></a>一、while和do while中的continue</h3><p>while中遇到continue，程序直接进入下一次迭代。</p>
<h3 id="二、for中的continue"><a href="#二、for中的continue" class="headerlink" title="二、for中的continue"></a>二、for中的continue</h3><p>for循环中遇到continue，程序会跳过本次迭代剩余的部分，<strong>再更新表达式求值</strong>，再进入下一次迭代。</p>
]]></content>
      <tags>
        <tag>C/C++笔记</tag>
        <tag>continue</tag>
      </tags>
  </entry>
  <entry>
    <title>声明函数有什么作用？</title>
    <url>/archives/29ba80af.html</url>
    <content><![CDATA[<p>如果你的c程序里面包含自定义函数，那么主函数前可能会有该自定义函数的函数原型，因为大部分编译器要求使用自定义函数时，要在main函数前声明函数。而函数声明的作用是把函数的名字、函数类型以及形参类型、个数和顺序通知编译系统，以便在调用该函数时系统按此进行对照检查（例如函数名是否正确，实参与形参的类型和个数是否一致）。  </p>
<h3 id="函数声明的形式："><a href="#函数声明的形式：" class="headerlink" title="函数声明的形式："></a>函数声明的形式：</h3><p>返回类型 函数名(参数1类型 参数1，参数2类型 参数2，……); 如：<strong>int diy_fuc(int a,int b);</strong></p>
]]></content>
      <tags>
        <tag>C/C++笔记</tag>
        <tag>函数声明</tag>
      </tags>
  </entry>
  <entry>
    <title>字段宽度为何物</title>
    <url>/archives/af0811ff.html</url>
    <content><![CDATA[<h3 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h3><p>#include&lt;stdio.h&gt;<br>#define STRING “<a href="http://www.scanf.top&quot;" target="_blank" rel="noopener external nofollow noreferrer">www.scanf.top&quot;</a></p>
<p>int main ( void )<br>{</p>
<pre><code>printf(&quot;%13s\\n&quot;,STRING);
printf(&quot;%14s\\n&quot;,STRING);
printf(&quot;%15s\\n&quot;,STRING);
printf(&quot;%16s\\n&quot;,STRING);
printf(&quot;%17s\\n&quot;,STRING);
printf(&quot;%18s\\n&quot;,STRING);
printf(&quot;%18s\\n&quot;,STRING);
printf(&quot;%17s\\n&quot;,STRING);
printf(&quot;%16s\\n&quot;,STRING);
printf(&quot;%15s\\n&quot;,STRING);
printf(&quot;%14s\\n&quot;,STRING);
printf(&quot;%13s&quot;,STRING);

return 0;</code></pre><p>}</p>
<h3 id="运行结果如下："><a href="#运行结果如下：" class="headerlink" title="运行结果如下："></a>运行结果如下：</h3><p><a href="http://www.scanf.top" target="_blank" rel="noopener external nofollow noreferrer">www.scanf.top</a><br> <a href="http://www.scanf.top" target="_blank" rel="noopener external nofollow noreferrer">www.scanf.top</a><br>  <a href="http://www.scanf.top" target="_blank" rel="noopener external nofollow noreferrer">www.scanf.top</a><br>   <a href="http://www.scanf.top" target="_blank" rel="noopener external nofollow noreferrer">www.scanf.top</a><br>    <a href="http://www.scanf.top" target="_blank" rel="noopener external nofollow noreferrer">www.scanf.top</a><br>     <a href="http://www.scanf.top" target="_blank" rel="noopener external nofollow noreferrer">www.scanf.top</a><br>     <a href="http://www.scanf.top" target="_blank" rel="noopener external nofollow noreferrer">www.scanf.top</a><br>    <a href="http://www.scanf.top" target="_blank" rel="noopener external nofollow noreferrer">www.scanf.top</a><br>   <a href="http://www.scanf.top" target="_blank" rel="noopener external nofollow noreferrer">www.scanf.top</a><br>  <a href="http://www.scanf.top" target="_blank" rel="noopener external nofollow noreferrer">www.scanf.top</a><br> <a href="http://www.scanf.top" target="_blank" rel="noopener external nofollow noreferrer">www.scanf.top</a><br><a href="http://www.scanf.top" target="_blank" rel="noopener external nofollow noreferrer">www.scanf.top</a></p>
<p>示例代码<a href="https://www.scanf.top/cnotes/95.html" target="_blank" rel="noopener external nofollow noreferrer">printf</a>函数中%与s之间的数字的作用是限定输出的字段宽度，可知运行结果中第一行输出“<a href="http://www.scanf.top”共占13个字符，即13列。第二行输出“" target="_blank" rel="noopener external nofollow noreferrer">www.scanf.top”共占13个字符，即13列。第二行输出“</a> <a href="http://www.scanf.top”，该行包括前面的空格共占14个字符，即14列。" target="_blank" rel="noopener external nofollow noreferrer">www.scanf.top”，该行包括前面的空格共占14个字符，即14列。</a></p>
]]></content>
      <tags>
        <tag>C/C++笔记</tag>
        <tag>字段宽度</tag>
      </tags>
  </entry>
  <entry>
    <title>指针数组和数组指针</title>
    <url>/archives/ea0c206d.html</url>
    <content><![CDATA[<h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><p>（1）指针数组：它实际上是一个数组，数组的每个元素存放的是一个指针类型的元素。</p>
<p>int* arr[8];<br>//优先级问题：[]的优先级比*高<br>//说明arr是一个数组，而int*是数组里面的内容<br>//这句话的意思就是：arr是一个含有8和int*的数组</p>
<p>（2）数组指针：它实际上是一个指针，该指针指向一个数组。</p>
<p>int (*arr)[8];<br>//由于[]的优先级比*高，因此在写数组指针的时候必须将*arr用括号括起来<br>//arr先和*结合，说明p是一个指针变量<br>//这句话的意思就是：指针arr指向一个大小为8个整型的数组。</p>
<h3 id="二、传参"><a href="#二、传参" class="headerlink" title="二、传参"></a>二、传参</h3><h4 id="1、一维数组传参"><a href="#1、一维数组传参" class="headerlink" title="1、一维数组传参"></a>1、一维数组传参</h4><p>#include &lt;stdio.h&gt;<br>//传参方式正确<br>//用数组的形式传递参数，不需要指定参数的大小，因为在一维数组传参时，形参不会真实的创建数组，传的只是数组首元素的地址。（如果是变量的值传递，那么形参就是实参的一份拷贝）<br>void test(int arr[])<br>{}</p>
<p>//传参方式正确<br>//不传参数可以，传递参数当然也可以<br>void test(int arr[10])<br>{}</p>
<p>//传参方式正确<br>//一维数组传参退化，用指针进行接收，传的是数组首元素的地址<br>void test(int *arr)<br>{}</p>
<p>//传参方式正确<br>//*arr[20]是指针数组，传过去的是数组名<br>void test2(int *arr[20])<br>{}</p>
<p>//传参方式正确<br>//传过去是指针数组的数组名，代表首元素地址，首元素是个指针向数组的指针，再取地址，就表示二级指针，用二级指针接收<br>void test2(int **arr)<br>{}<br>int main()<br>{<br>int arr[10] = {0};<br>int *arr2[20] = {0};<br>test(arr);<br>test2(arr2);<br>}</p>
<h4 id="2、二维数组传参"><a href="#2、二维数组传参" class="headerlink" title="2、二维数组传参"></a>2、二维数组传参</h4><p>//传参正确<br>//表明二维数组的大小，三行五列<br>void test(int arr[3][5])<br>{}</p>
<p>//传参不正确<br>//二维数组的两个方括号，不能全部为空，也不能第二个为空，只能第一个为空<br>void test(int arr[][])<br>{}</p>
<p>//传参正确<br>//可以写成如下这样传参形式，但是不能写int arr[3][]<br>void test(int arr[][5])<br>{}</p>
<p>//传参不正确<br>//arr是一级指针，可以传给二维数组，但是不能正确读取<br>void test(int *arr)<br>{}</p>
<p>//传参不正确<br>//这里的形参是指针数组，是一维的，可以传参，但是读取的数据不正确<br>void test(int* arr[5])<br>{}</p>
<p>//传参正确<br>//传过去的是二维数组的数组名，即数组首元素的地址，也就是第一行的地址，第一行也是个数组，用一个数组指针接收<br>void test(int (*arr)[5])<br>{}</p>
<p>//传参不正确<br>//可以传参，但是在读取的时候会有级别不同的问题<br>void test(int **arr)<br>{}<br>int main()<br>{<br>int arr[3][5] = {0};<br>test(arr);<br>}</p>
]]></content>
      <tags>
        <tag>C/C++笔记</tag>
        <tag>指针数组</tag>
        <tag>数组指针</tag>
      </tags>
  </entry>
  <entry>
    <title>数组和指针的区别</title>
    <url>/archives/84fab74c.html</url>
    <content><![CDATA[<h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><ul>
<li><strong>数组</strong>：数组是用于储存多个相同类型数据的集合。</li>
<li><strong>指针</strong>：指针相当于一个变量，但是它和其它的变量不一样，它存放的是其它变量在内存中的地址。</li>
</ul>
<p><strong>数组名是地址常量，指针名是指针变量。</strong></p>
<h4 id="二、赋值、存储方式、求sizeof、初始化等-1-赋值"><a href="#二、赋值、存储方式、求sizeof、初始化等-1-赋值" class="headerlink" title="二、赋值、存储方式、求sizeof、初始化等 1.赋值"></a>二、赋值、存储方式、求sizeof、初始化等 1.赋值</h4><p>同类型指针变量可以相互赋值，数组不行，只能一个一个元素的赋值或拷贝</p>
<h4 id="2-存储方式"><a href="#2-存储方式" class="headerlink" title="2.存储方式"></a>2.存储方式</h4><p><strong>数组</strong>：数组在内存中是连续存放的，开辟一块连续的内存空间。数组是根据数组的下标进行访问的，多维数组在内存中是按照一维数组存储的，只是在逻辑上是多维的。 数组的存储空间，不是在静态区就是在栈上。 <strong>指针</strong>：指针很灵活，它可以指向任意类型的数据。指针的类型说明了它所指向地址空间的内存。 指针：由于指针本身就是一个变量，再加上它所存放的也是变量，所以指针的存储空间不能确定。</p>
<h4 id="3-求sizeof"><a href="#3-求sizeof" class="headerlink" title="3.求sizeof"></a>3.求sizeof</h4><p><strong>数组：</strong> 数组所占存储空间的内存：sizeof（数组名） 数组的大小：sizeof（数组名）/sizeof（数据类型） <strong>指针：</strong> 在32位平台下，无论指针的类型是什么，sizeof（指针名）都是4，在64位平台下，无论指针的类型是什么，sizeof（指针名）都是8。</p>
<blockquote>
<p>原文链接：<a href="https://blog.csdn.net/cherrydreamsover/article/details/81741459" target="_blank" rel="noopener external nofollow noreferrer">https://blog.csdn.net/cherrydreamsover/article/details/81741459</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>C/C++笔记</tag>
        <tag>指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>无缓冲输入和缓冲输入</title>
    <url>/archives/d45baae6.html</url>
    <content><![CDATA[<h3 id="什么是无缓冲输入和缓冲输入？"><a href="#什么是无缓冲输入和缓冲输入？" class="headerlink" title="什么是无缓冲输入和缓冲输入？"></a>什么是无缓冲输入和缓冲输入？</h3><p>无缓冲输入：用户输入字符后立即打印该字符。 缓冲输入：用户输入的字符被收集并存储在一个叫做缓冲区的临时存储区，按下<strong>Enter</strong>键后，程序才使用用户输入的字符。</p>
<h3 id="为什么要有缓冲区？"><a href="#为什么要有缓冲区？" class="headerlink" title="为什么要有缓冲区？"></a>为什么要有缓冲区？</h3><p>首先，把若干字符作为一个块进行传输比逐个发送这些字符节约时间。其次，如果用户打错字符，可以直接通过键盘修正错误。当最后按下Enter键时，传输的是正确的输入。</p>
]]></content>
      <tags>
        <tag>C/C++笔记</tag>
        <tag>缓冲区</tag>
      </tags>
  </entry>
  <entry>
    <title>文本模式和二进制模式</title>
    <url>/archives/21d0fb11.html</url>
    <content><![CDATA[<h3 id="文件的定义：文件是在磁盘上一段已命名的存储区-。"><a href="#文件的定义：文件是在磁盘上一段已命名的存储区-。" class="headerlink" title="_文件的定义：文件是在磁盘上一段已命名的存储区_。"></a>_文件的定义：文件是在磁盘上一段已命名的<strong>存储区</strong>_。</h3><h3 id="一、疑惑"><a href="#一、疑惑" class="headerlink" title="一、疑惑"></a>一、疑惑</h3><p>在学习C语言读取文件的时候，首先学习到的是C语言读取文件时分文本模式和二进制模式。给好多人造成疑惑，文件存储时要分类？二进制存储和文本存储完全不相同？对于纯文本必须使用文本模式？对于纯数字必须使用二进制模式？如果你对这些有疑惑，这篇文章适合你，如果你是来看函数时如何使用的，可能你要另寻他处了。</p>
<h3 id="二、明白关键一点"><a href="#二、明白关键一点" class="headerlink" title="二、明白关键一点"></a>二、明白关键一点</h3><p>任何数据在内存中或者硬盘上的存储都是1、0组成的序列，从硬盘、内存这个角度看根本不存在什么二进制和文本模式之分。</p>
<h3 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h3><p>稍对C语言操作文件有了解都知道2点：1、首先应该fopen打开文件2、有两类文件操作函数，对应着二进制模式和文本模式。 两个模式的区别在两个地方，这两个地方的区别正好体现在刚才说的2点上。</p>
<h4 id="1、-打开文件时选择模式"><a href="#1、-打开文件时选择模式" class="headerlink" title="1、 打开文件时选择模式"></a>1、 打开文件时选择模式</h4><p>使用fopen函数时，要给予第二个参数一个值，告诉fopen使用什么模式打开文件。这里的参数决定的就是第一个区别：对于字符串中的\n如何处理？ 教材中说，文本模式中，在存储\n时要转化为\r\n，读取文件时进行逆转换。二进制模式时，则不进行转换。当然这是在操作系统是Windows的条件下。 首先我们要知道回车和换行是不相同的，Windows中文字另起一行内存表示为&lt;回车&gt;&lt;换行&gt;对应\r\n，而Linux、Unix中则是单单一个&lt;换行&gt;对应\n。Mac中则是一个&lt;回车&gt;对应\r C语言起源于Unix的产生，对于文件中的另起一行，Unix采用单个\n表示。所以我们通常在输出一个短话想换行时加一个\n就可以了，Windows也是如此。到了数据从内存到硬盘上进行存储时，对于unix来说，\n照样是\n。而Windows为了防止读取时混乱必须转换为\r\n。Mac呢，就是\r。 这就是第一区别，这个区别是体现在fopen第二个参数，跟你使用文本模式的函数还是二进制模式的函数根本不相关！你可以做一个实验，使用二进制模式的函对于同样的字符串:”Hello\n”，当fopen使用w参数写入文件，无论是fwrite还是fprintf都会对\n会进行转换，而使用wb参数则都不进行转换。</p>
<h4 id="2、-两种不同模式的函数"><a href="#2、-两种不同模式的函数" class="headerlink" title="2、  两种不同模式的函数"></a>2、  两种不同模式的函数</h4><p>打开文件后，要进行数据写入。 教材中说，使用文本模式打开文件，就要用fprintf写入数据，使用二进制模式打开文件，就要用fwrite写入数据。 其实你用文本模式打开文件，一个字符串，fprintf、fwrite都能写入文件，写入还都是一样的数据。使用两类函数的区别其实在于数字的处理上。 对于一个数字5，你用fprintf写入，将把数字5转换为字符5，将其对应的ASCII编码存入存储器，占用1个字节。但实际上数字5就是数字5，对应2进制101，整形占用4个字节。fwrite则将这个数字在内存中占用的4个字节全部原样写入到硬盘中，占4个字节。 而同样对于一段字符串”Hello”，使用ASCII编码对于fprintf和fwrite都能原样写到硬盘中。 同样对于这个区别，你仍然能做个实验，对于一个int型数字5，你如何用fprintf和fwrite写入到硬盘中，他们对应的十六进制码是多少？对于一段字符串你再用两个函数分别写到硬盘中，你看看对应的十六进制码是什么。这个实验跟你用fopen如何指定第二个参数无关。</p>
<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>文本模式和二进制模式其实就2个简单的区别，抓住这两个核心完全能搞懂两种模式的不同。 对于第一个区别完全是因为操作系统的差异导致，C作为一个跨平台的语言必须要设计一种方法解决这个跨平台的问题，如果3个平台对于另起一行这个操作统一是不存在这第一个区别的 对于第二个区别，一切数据的存储都是二进制1、0存储，只不过对于数字，既可以认为是一个数字，也可以认为是一个字符，这就是产生第二个区别的原因   （转自CSDN技术博客 <a href="https://blog.csdn.net/zrf2112/article/details/51996003" target="_blank" rel="noopener external nofollow noreferrer">原文链接</a>）</p>
]]></content>
      <tags>
        <tag>C/C++笔记</tag>
        <tag>二进制模式</tag>
        <tag>文本模式</tag>
      </tags>
  </entry>
  <entry>
    <title>理解函数递归调用的过程</title>
    <url>/archives/9a3fe690.html</url>
    <content><![CDATA[<p>C允许函数调用它自己，这种调用过程称为递归。</p>
<h3 id="一、演示递归"><a href="#一、演示递归" class="headerlink" title="一、演示递归"></a>一、演示递归</h3><p>#include&lt;stdio.h&gt;<br>int ken(int b);<br>int main( void )<br>{<br>    int b,c;<br>    scanf(“%d”,&amp;b);<br>    c=ken(b);<br>    printf(“%d”,c);</p>
<pre><code>return 0;</code></pre><p>}<br>int ken(int b)<br>{<br>    if(b&gt;1)<br>    {<br>        b=b*ken(b-1);<br>    printf(“%d\n”,b);<br>    }<br>    return b; //将b的值返回给上一级调用函数<br>}</p>
<p>这是一个演示递归的程序，递归函数调用的过程如下图：</p>
<p><img src="https://scanf.top/wp-content/uploads/2019/08/fullsizerender.jpg" alt=""></p>
]]></content>
      <tags>
        <tag>C/C++笔记</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>清除缓冲区的字符</title>
    <url>/archives/3e3b1e2a.html</url>
    <content><![CDATA[<h3 id="演示程序："><a href="#演示程序：" class="headerlink" title="演示程序："></a>演示程序：</h3><p>#include&lt;stdio.h&gt;<br>#include&lt;conio.h&gt; //for getch()</p>
<p>int main ( void )<br>{<br>    int guess=1;<br>    char ch;<br>    printf(“这是一个猜数字的程序，你可以先在纸上写一个数字”);<br>    printf(“写好之后按下任意键继续…\n”);<br>    getch();<br>    printf(“你写在纸上的数字是%d吗？”,guess);<br>    while((ch=getchar())!=’y’){<br>        if(ch==’n’){<br>            printf(“好的，那这个数字是%d吗?\n”,++guess);<br>        }<br>        else{<br>            printf(“sorry,只能识别y和n.\n”);<br>        }<br>        printf(“\t正在清除多余的字符：\n”) ;<br>        while((ch=getchar())!=’\n’){<br>            printf(“\t本次清除的字符是：%c\n”,ch);<br>            continue;<br>        }</p>
<pre><code>}

printf(&quot;也许，我真的猜对了!\\n&quot;);

return 0;</code></pre><p>}</p>
<h3 id="程序解读："><a href="#程序解读：" class="headerlink" title="程序解读："></a>程序解读：</h3><p>请不要介意这个程序的算法，因为这个程序主要的用途是演示用while清除缓存区的字符。原代码是：</p>
<p>while((ch=getchar())!=’\n’){continue; }</p>
<p>为了更直观的刻画缓冲清除过程，改进代码如下：</p>
<p>printf(“\t正在清除多余的字符：\n”) ;<br>        while((ch=getchar())!=’\n’){<br>            printf(“\t本次清除的字符是：%c\n”,ch);<br>            continue;<br>        }</p>
<p>当用户输入no,it is wrong!时，外层while循环将该字符串全部读取，但是本次仅将首字母n赋给ch字符变量，其余的字符全部写入缓冲区，由后面若干个getchar()读取。该程序实现希望缓冲区的字符不要干扰外层while循环，而影响程序输出，因此在外层while循环中再嵌入一个while循环，实现在进入下一次外层while循环前将缓冲区的字符全部清除，即将缓冲区的字符挨个读取一遍。 你可以自己debug一下，感受程序执行的过程。</p>
]]></content>
      <tags>
        <tag>C/C++笔记</tag>
        <tag>缓冲区</tag>
      </tags>
  </entry>
  <entry>
    <title>缓冲流的存在有什么意义？</title>
    <url>/archives/4115c28f.html</url>
    <content><![CDATA[<p>BufferedInputStream和BufferedoutputStream是FilterInputStream和FilterOutputStream的子类，可以避免每次发送或者写数据的时候，进行实际的写操作，使用的是缓冲区； 不应用缓冲区的时候，每次读取一个字节，写入一个字节，由于操作磁盘比内存慢的很多，所以不应用缓冲区效率很低； 应用缓冲区，可以一次读取多个字节，先不写入磁盘，而是放入内存之中，到了缓冲区大小的时候，在写入磁盘，减少了对磁盘的操作，效率高； 应用缓冲流，在结束的时候，调用flush和close方法，将缓冲区的数据都清理出来，，写入磁盘，否则可能无数据； 当写文件需要flush()的效果时，需要  FileOutputStream fos = new FileOutputStream(“c:\a.txt”);  BufferedOutputStream bos = new BufferedOutputStream(fos);  也就是说，需要将FileOutputStream作为BufferedOutputStream构造函数的参数传入，然后对BufferedOutputStream进行写入操作，才能利用缓冲及flush()。 1.BufferedOutputStream在close()时会自动flush  2.BufferedOutputStream在不调用close()的情况下，缓冲区不满，又需要把缓冲区的内容写入到文件或通过网络发送到别的机器时，才需要调用flush. ———————————————— 原文链接：<a href="https://blog.csdn.net/HEB\_ZZQ/java/article/details/80944570" target="_blank" rel="noopener external nofollow noreferrer">https://blog.csdn.net/HEB\_ZZQ/java/article/details/80944570</a></p>
]]></content>
      <tags>
        <tag>java笔记</tag>
        <tag>缓冲流</tag>
      </tags>
  </entry>
  <entry>
    <title>没有花括号的while循环</title>
    <url>/archives/215d6fa0.html</url>
    <content><![CDATA[<p>有如下一个while示例：</p>
<p>while ( x &gt; 1 )<br>语句a;<br>语句b;<br>……</p>
<p>这是一个没有花括号的while循环。圆括号中的条件一直为真就一直执行语句a，条件为假将跳过语句a，并跳出循环执行语句a下面的语句，本例中将执行从语句b开始以下的语句。</p>
]]></content>
      <tags>
        <tag>C/C++笔记</tag>
        <tag>while</tag>
      </tags>
  </entry>
  <entry>
    <title>链表中增加头结点的作用</title>
    <url>/archives/10ef29c7.html</url>
    <content><![CDATA[<p>理解单链表中头结点的作用，只需要了解对有头结点的单链表和无头结点的单链表操作的区别 下面写两个函数，删除单链表中的一个结点。</p>
<h4 id="①、删除无头结点单链表中的一个结点"><a href="#①、删除无头结点单链表中的一个结点" class="headerlink" title="①、删除无头结点单链表中的一个结点"></a>①、删除无头结点单链表中的一个结点</h4><p><img src="https://scanf.top/wp-content/uploads/2020/02/fullsizerender5-300x84.jpg" alt=""></p>
<p>[算法思想] 1、设要删除的结点为p。 2、如果p指向首元结点：L = p -&gt; next; 3、如果p指向的是除首元结点外其他任意结点，执行以下操作： Step 1: 获取p的前驱结点为s; Step 2: s -&gt; next = p -&gt; next.</p>
<h4 id="②、删除有头结点单链表中的一个结点"><a href="#②、删除有头结点单链表中的一个结点" class="headerlink" title="②、删除有头结点单链表中的一个结点"></a>②、删除有头结点单链表中的一个结点</h4><p><img src="https://scanf.top/wp-content/uploads/2020/02/fullsizerender4-300x62.jpg" alt=""></p>
<p>[算法思想] 1、设要删除的结点为p。 2、p指向的是任意结点（包括首元结点），执行以下操作： Step 1: 获取p的前驱结点为s; Step 2: s -&gt; next = p -&gt; next;</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结</strong>：</h3><p>在有头结点的情况下，无需特殊处理首元结点。设置头结点可以保证处理第一个结点和后面的结点时设计的算法相同，实现程序的高效性。</p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>链表</tag>
        <tag>头结点</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合框架</title>
    <url>/archives/9753a2e.html</url>
    <content><![CDATA[<h1 id="一、列表List"><a href="#一、列表List" class="headerlink" title="一、列表List"></a>一、列表List</h1><h2 id="1-1-ArrayList"><a href="#1-1-ArrayList" class="headerlink" title="1.1 ArrayList"></a>1.1 ArrayList</h2><ul>
<li>特点：非同步，基于Object对象数组实现。访问效率高。</li>
<li>适用场景：随机访问, 适用于经常访问数据元素的场景。因删除和插入的操作会经历大量数据元素的移动的过程，时间复杂度较高，故不适用于经常有删除和插入操作的场景。</li>
</ul>
<h2 id="1-2-LinkedList"><a href="#1-2-LinkedList" class="headerlink" title="1.2 LinkedList"></a>1.2 LinkedList</h2><ul>
<li>特点：非同步，基于双向链表实现。</li>
<li>适用场景：顺序访问，访问数据元素的效率不高，适用于经常删除、插入和移动元素的场景。</li>
<li><a id="more"></a>

</li>
</ul>
<h2 id="1-3-Vector"><a href="#1-3-Vector" class="headerlink" title="1.3 Vector"></a>1.3 Vector</h2><ul>
<li>特点：同步的，基于Object数组实现。</li>
<li>适用场景：与ArrayList几乎一样。</li>
</ul>
<h1 id="二、集合Set"><a href="#二、集合Set" class="headerlink" title="二、集合Set"></a>二、集合Set</h1><p>Set的三大性质：</p>
<blockquote>
<ol>
<li><p>确定性：给定一个集合，任给一个元素，该元素或者属于或者不属于该集合，二者必居其一，不允许有模棱两可的情况出现。</p>
</li>
<li><p>互异性： 一个集合中，任何两个元素都认为是不相同的，即每个元素只能出现一次。</p>
</li>
<li><p>无序性：一个集合中，每个元素的地位都是相同的,元素之间是无序的。</p>
</li>
</ol>
</blockquote>
<h2 id="2-1-HashSet"><a href="#2-1-HashSet" class="headerlink" title="2.1 HashSet"></a>2.1 HashSet</h2><ul>
<li>特点：不支持同步，基于HashMap实现，无序（元素遍历输出的顺序和插入顺序不一致），可以容纳null元素。</li>
</ul>
<h2 id="2-2-TreeSet"><a href="#2-2-TreeSet" class="headerlink" title="2.2 TreeSet"></a>2.2 TreeSet</h2><ul>
<li>特点：不支持同步，基于HashMap实现，可排序（默认按照字典顺序排序），可容纳null元素。</li>
</ul>
<h2 id="2-3-LinkedHashSet"><a href="#2-3-LinkedHashSet" class="headerlink" title="2.3 LinkedHashSet"></a>2.3 LinkedHashSet</h2><ul>
<li>特点：不支持同步，基于TreeMap实现，排序（默认按照插入顺序排序），不可以容纳null元素。</li>
</ul>
<hr>
<h2 id="2-4-判断重复元素"><a href="#2-4-判断重复元素" class="headerlink" title="2.4 判断重复元素"></a>2.4 判断重复元素</h2><ul>
<li>HashSet和LinkedList根据hashCode()和equals()方法判断重复元素。</li>
<li>TreeSet根据重写的compareTo()方法判断重复元素</li>
</ul>
<hr>
<p>三者都可以通过Collections工具实现同步，方法如下：</p>
<pre><code>Set s = Collections.synchronizedSet( new HashSet() );</code></pre><p>该方法可以获得一个支持同步的Set对象。</p>
<h1 id="三、映射Map"><a href="#三、映射Map" class="headerlink" title="三、映射Map"></a>三、映射Map</h1><h2 id="3-1-Hashtable"><a href="#3-1-Hashtable" class="headerlink" title="3.1 Hashtable"></a>3.1 Hashtable</h2><ul>
<li>特点：同步的，速度较慢，适用于数据量较小的场景。K-V军不允许出现null。遍历顺序和put顺序无关。</li>
</ul>
<h2 id="3-2-HashMap"><a href="#3-2-HashMap" class="headerlink" title="3.2 HashMap"></a>3.2 HashMap</h2><ul>
<li>特点：不支持同步，速度较快，适用于数据量较大的场景。K-V允许为null。这是一个新的类，不支持Enumeration遍历。可以用Collections工具将HashMap对象转化为支持同步的Map对象。遍历顺序和put顺序无关。</li>
</ul>
<h2 id="3-3-ProperTies"><a href="#3-3-ProperTies" class="headerlink" title="3.3 ProperTies"></a>3.3 ProperTies</h2><ul>
<li>特点：同步的，文件的形式保存K-V对，适用于数据量较小的场景。</li>
</ul>
<h2 id="3-4-LinkedHashMap"><a href="#3-4-LinkedHashMap" class="headerlink" title="3.4 LinkedHashMap"></a>3.4 LinkedHashMap</h2><ul>
<li>特点：基于双向链表维持插入顺序。遍历顺序和插入顺序一致。</li>
</ul>
<h2 id="3-5-TreeMap"><a href="#3-5-TreeMap" class="headerlink" title="3.5 TreeMap"></a>3.5 TreeMap</h2><ul>
<li>特点：基于红黑树的Map，可以根据key的自然顺序排序或者根据compareTo方法排序。</li>
</ul>
<h1 id="四、工具类"><a href="#四、工具类" class="headerlink" title="四、工具类"></a>四、工具类</h1><p>不存储数据，而是在数据容器上，实现高效的操作。</p>
<h2 id="4-1-Arrays"><a href="#4-1-Arrays" class="headerlink" title="4.1 Arrays"></a>4.1 Arrays</h2><p>处理数组，常用方法：</p>
<ul>
<li>sort 分类</li>
<li>binarySearch 二分查找</li>
<li>copyOf 从源数组批量复制元素到目标数组</li>
<li>fill 对数组进行批量赋值</li>
<li>equals 判定两数组内容是否相同</li>
</ul>
<h2 id="4-2-Collections"><a href="#4-2-Collections" class="headerlink" title="4.2 Collections"></a>4.2 Collections</h2><p>处理collection类及其子类，常用方法：</p>
<ul>
<li>sort 分类</li>
<li>binarySearch 二分查找</li>
<li>max、min</li>
<li>fill 对数组进行批量赋值</li>
<li>reverse 将List反序排列</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>java笔记</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>byte类型的取值为什么是-128~127</title>
    <url>/archives/370b7f8.html</url>
    <content><![CDATA[<p>Java的byte类型取值范围是-128~127为什么是-128到127呢 <img src="https://scanf.top/wp-content/uploads/2020/02/6d92da42982fdc702b0297ff13f4de64.png" alt=""></p>
<h3 id="一、首先需要了解原码反码和补码"><a href="#一、首先需要了解原码反码和补码" class="headerlink" title="一、首先需要了解原码反码和补码"></a>一、首先需要了解原码反码和补码</h3><p>正数的原码反码补码是一样的 [+2]=[00000010]原=[00000010]反=[00000010]补 对于负数来说，它的原码反码补码就不相同 [-2]=[10000010]原=[11111101]反=[11111110]补 最高位表示符号位0代表正数1代表负数，负数计算反码的规则是符号位不变，其余位取反即1变成0,0变成1，补码就是反码再加1</p>
<h3 id="二、为什么要设计出反码和补码"><a href="#二、为什么要设计出反码和补码" class="headerlink" title="二、为什么要设计出反码和补码"></a>二、为什么要设计出反码和补码</h3><p>因为计算机只有加法没有，减法，在做减法运算的时候，可以认为是加上一个负数，这样可以减少计算机电路的复杂度。 使用原码进行减法运算会出现问题，例如计算1-1，因为计算机没有加法只有减法，所以计算机自动换算成1+(-1) 1-1=1+(-1)=[00000001]原+[10000001]原=[10000010]原=-2 （符号位也参与运算） 而1-1的实际结果是0. 为了解决这个问题，于是使用反码运算 1-1=1+(-1)=[00000001]原+[10000001]原=[00000001]反+[11111110]反=[11111111]反=[10000000]原=-0 通过反码计算的结果是11111111在计算一次反就成原码了，得出的结果是正确的，但是有一个问题是 00000000可以代表+0。 10000000可以代表-0，其实是一样的，用2个编码实在是浪费。于是出现了补码解决0的符号以及两个编码的问题。 1-1=1+(-1)=[00000001]原+[10000001]原=[00000001]补+[11111111]补=[00000000]补=[00000000]原 这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128:但是注意<strong>因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示</strong>.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的) 使用补码，不仅仅修复了0的符号以及存在两个编码的问题，而且还能够多表示一个最低数。这就是为什么8位二进制，使用原码或者反码表示的范围是[-127<del>127],而使用补码表示的范围为[-128</del>127] <strong>总结：反码是为了解决减法运算，补码是为了解决反码产生的+-0的问题</strong>  </p>
<h3 id="三、下面来分析为什么byte型的取值范围为什么是-128-127"><a href="#三、下面来分析为什么byte型的取值范围为什么是-128-127" class="headerlink" title="三、下面来分析为什么byte型的取值范围为什么是-128~127"></a>三、下面来分析为什么byte型的取值范围为什么是-128~127</h3><p>1，byte占用8位，每位用0或者1表示，能够表示258(2^8)个数据 2，这8位分为符号位（最高位）和数值位(剩余七位)，符号位0表示正数，1表示负数。 3，按上一步的理解，容易得到（+127：0111 1111、+1：0000 0001、+0：0000 0000、-0：1000 0000、-1：1000 0001、-127：1111 1111），计算机底层定义了+0（0000 0000）就是0，那么“可怜的-0”又该何去何从呢？计算机遇到这个二进制该如何处理呢？总不能把这两个都对应0吧，这显然是资源浪费。 4，到这里我们都认为最高位是不参与计算数值的，仅仅是一个符号位，按这种思路byte的八位是无论如何也表示不出-128。而“可怜的-0”又不知道自己代表谁，不得而知“可怜的-0”就是-128。 5，到这里我们已经很粗浅地回答了-128<del>127中的-128的由来，基本也回答了这个题目。 6，可是对于程序员来说，上诉的分析【首先】是结论正确，但是过程错了。错误在于，负数的二进制表示是错误的，比如-127：1111 1111，这是不对的。计算机发现了1111 1111会把它认为是-1而不是-127。【其次】没有解释为什么-0最后表示成-128。 7，计算机基础知识补充 &lt;1&gt;计算机存储有符号的整数是都是存储它们的补码。Java语言都是有符号位的。 &lt;2&gt;正数和0的补码、反码是本身原码；所以对于正数来说，可以理解为不存在反码和补码。 &lt;3&gt;负数的反码是是符号位不变，其它位取反；补码是在负数的基础上加1（符号位不变）。负数就是矫情啊！ &lt;4&gt;计算机中用补码进行减法运算。 8，接着从人的思考方式理解下当计算机处理1111 1111的过程，首位是1，自然是负数，而且这是补码，那么对应的原码就是，先减1，变成1111 1110，符号位不变，其他取反，变成1000 0001，也就是-1！所以从10000001到11111111依次表示-127到-1 9，最后来解决这-128为什么可以用100000000表示 这里我分析的是byte，它就8位。在无符号位的二进制中128的表示为1000 0000。有符号位的情况下byte好像无法表示+128或-128。 如果我们假设byte不是占用8位，而是9位，最高位是符号位。你们-128的表示为1 10000 0000，计算其补码也是1 1000 0000，很神奇吧，一样的。-128补码尾8位就是1000 0000。那就规定1000 0000是-128的补码，而-128是没有原码和反码的，即不能利用10000 0000反推其反码和原码。 10，如果你对9步的推导表示不太接受，那么<strong>简单就认为计算机规定了1000 0000就是-128</strong>，是一种人为设计没有什么道理可以言（据说是印度阿三设计的）。其实这么设计也是很巧妙的，在于： 【其一】对于如果大于8位的有符号整数数据类型，-128的补码尾八位刚好是1000 0000 【其二】比如127（0111 1111）加1（0000 0001）刚好得到-128（1000 0000），-128（1000 0000）加1（0000 00001）等于-127（1000 0001）这样从-128</del>127的反码首尾相连,形成了一个闭环，就像时钟一样。 【其三】在计算机中减法运算可以转换成加法运算，比如8-1——&gt;8+(-1)——&gt;补码运算：(0000 1000) + (1111 1111) = (0000 0111) 刚好是7。-128+127——&gt;(1000 0000) + (0111 1111) = （1111 1111）刚好是-1，-128的补码完美的适用于减法。 结论 【1】计算机中负数是用补码的形式保存、并用它参与加减法运算的，减法会被转换为加法，计算机中没有加法运算。 【2】反码是为了解决减法运算，补码是为了解决反码产生的±0的问题。参考(<a href="https://blog.csdn.net/boatalways/article/details/17027573" target="_blank" rel="noopener external nofollow noreferrer">https://blog.csdn.net/boatalways/article/details/17027573</a>) 【3】对人而言二进制所代表的值一定是从原码求出的，开头如果是1的二进制，一定要说明其实原码、反码还是补码。 【4】在原码、反码、补码相互转换以及求对应的十进制求值时，符号位是绝不参与的，但是在加减过程中，是参与位运算的。 【5】计算机中规定了-0对应的二进制就是0，那么-0就没有意义了，必须找一个数和它对应。 【6】byte的最小值-128、short的最小值-32768、int的最小值-2147483648都是用对应的-0的原码来进行表示，这是人为规定的、人为规定的、人为规定的。但是这么规定又很巧妙，妙在上述10中的三点。  </p>
<blockquote>
<p>本文转载自：<a href="https://www.cnblogs.com/minseo/p/11733782.html" target="_blank" rel="noopener external nofollow noreferrer">https://www.cnblogs.com/minseo/p/11733782.html</a> 参考：<a href="https://blog.csdn.net/qq_22771739/article/details/84496115" target="_blank" rel="noopener external nofollow noreferrer">https://blog.csdn.net/qq_22771739/article/details/84496115</a> <a href="https://blog.csdn.net/boatalways/article/details/17027573" target="_blank" rel="noopener external nofollow noreferrer">https://blog.csdn.net/boatalways/article/details/17027573</a> <a href="https://blog.csdn.net/zhiwen_a/article/details/81192087" target="_blank" rel="noopener external nofollow noreferrer">https://blog.csdn.net/zhiwen_a/article/details/81192087</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>java笔记</tag>
        <tag>整型byte</tag>
      </tags>
  </entry>
  <entry>
    <title>并发与并行的区别</title>
    <url>/archives/6292c650.html</url>
    <content><![CDATA[<p>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。 你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。 你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。 并发的关键是你有处理多个任务的能力，不一定要同时。并行的关键是你有同时处理多个任务的能力。所以我认为它们最关键的点就是：是否是『同时』。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>java笔记</tag>
        <tag>并发</tag>
        <tag>并行</tag>
      </tags>
  </entry>
  <entry>
    <title>初识Java多线程编程</title>
    <url>/archives/22330b77.html</url>
    <content><![CDATA[<blockquote>
<p><strong>多线程的目的：</strong>较好的利用计算机CPU资源。</p>
</blockquote>
<h1 id="1-什么是线程、进程和多线程"><a href="#1-什么是线程、进程和多线程" class="headerlink" title="1 什么是线程、进程和多线程"></a><strong>1 什么是线程、进程和多线程</strong></h1><ul>
<li>线程 &gt; 线程是进程的一个循序控制流。</li>
<li>进程 &gt; 进程是程序运行的一个实例， 一个进程可以有多个线程。</li>
<li>多线程 &gt; Java多线程编程是一种机制，它允许在程序中并发执行多个指令流，每个指令流都是一个线程，彼此之间相互独立。</li>
</ul>
<h1 id="2-线程的生命周期"><a href="#2-线程的生命周期" class="headerlink" title="2 线程的生命周期"></a><strong>2 线程的生命周期</strong></h1><p>线程可以有五个状态，新建、就绪、运行、阻塞和消亡状态。 <img src="https://scanf.top/wp-content/uploads/2020/04/wp_editor_md_bcfc7815219ad1201f5ca052e97f057e.jpg" alt="线程生命周期"> 1. 新建：采用new语句创建完成。 2. 就绪：执行Start()方法后。 3. 运行：执行run()方法后，占用CPU时间。 4. 阻塞：阻塞是指在运行的线程没有运行结束，但是让出了CPU资源，这时其他处于就绪状态的线程就可以获得CPU时间，从而进入运行状态。Java线程中sleep(),suspend(),wait()等可以让线程阻塞，阻塞完成后，不会直接进入运行状态，而是要进入就绪队列等待，得到CPU资源后才可以运行。</p>
<h1 id="3-Java中实现多线程的两种方法"><a href="#3-Java中实现多线程的两种方法" class="headerlink" title="3 Java中实现多线程的两种方法"></a><strong>3 Java中实现多线程的两种方法</strong></h1><h2 id="3-1-方法一：继承Thread类，并覆写run-方法"><a href="#3-1-方法一：继承Thread类，并覆写run-方法" class="headerlink" title="3.1 方法一：继承Thread类，并覆写run()方法"></a><strong>3.1 方法一：继承Thread类，并覆写run()方法</strong></h2><p>代码演示：</p>
<pre><code>package top.scanf.Demo;

public class ThreadTest {
    public static void main(String[] args) {
        //Thread thread = new Thread(new Thread1(),&quot;线程一呀&quot;);
        Thread1 thread1 = new Thread1();//新建一个线程
        thread1.start();//让线程进入就绪状态
        System.out.println(&quot;main线程结束&quot;);
    }
}
class Thread1 extends Thread {
    @Override
    public void run() {
        int time = 0;
        while (time &lt;= 10) {
            System.out.println(&quot;线程一运行中&quot; + time);
            time++;
            try {
                Thread.sleep(100);//休眠100ms
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println(&quot;线程一结束&quot;);
    }
}</code></pre><h2 id="3-2-方法二：实现Runnable接口，并实现run-方法"><a href="#3-2-方法二：实现Runnable接口，并实现run-方法" class="headerlink" title="3.2 方法二：实现Runnable接口，并实现run()方法"></a><strong>3.2 方法二：实现Runnable接口，并实现run()方法</strong></h2><p>代码演示：</p>
<pre><code>package top.scanf.Demo;

public class RunnableTest {
    public static void main(String[] args) {
        //新建一个MyRunnable对象，并将该对象包装成Thread对象
        Thread newThread = new Thread(new MyRunnable(),&quot;Runnable1&quot;);
        newThread.start();//让线程进入就绪状态
        System.out.println(&quot;主线程结束&quot;);

    }
}
class MyRunnable implements Runnable {
    @Override
    public void run() {
        int time = 0;
        while (time &lt; 10) {
            System.out.println(&quot;线程一运行中&quot; + time);
            time++;
            try {
                Thread.sleep(300);//休眠300ms
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println(&quot;Runnable线程结束&quot;);
    }
}</code></pre><h1 id="4-线程的调度和同步问题"><a href="#4-线程的调度和同步问题" class="headerlink" title="4 线程的调度和同步问题"></a><strong>4 线程的调度和同步问题</strong></h1><h2 id="4-1-线程的调度"><a href="#4-1-线程的调度" class="headerlink" title="4.1 线程的调度"></a><strong>4.1 线程的调度</strong></h2><p>线程的调度模型：</p>
<ol>
<li><p>分时调度模型：所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间片。</p>
</li>
<li><p>抢占式调度模型：优先让优先级高的线程使用CPU,如果线程的优先级相同，则随机选择一个．</p>
</li>
</ol>
<p><strong>Java使用抢占式调度模型:</strong>一共有10个级别的线程优先级,可取1-10之间的整数,数值越大优先级越高,默认优先级是5,优先级越高的线程越容易被操作系统选择执行,但是优先级高的不一定先执行.</p>
<h2 id="4-2-线程的同步"><a href="#4-2-线程的同步" class="headerlink" title="4.2 线程的同步"></a><strong>4.2 线程的同步</strong></h2><p>为了解决多个线程访问同一个资源时可能会引发一些安全问题,需要实现多线程的同步,即限制某个资源在同一时刻只能被同一个线程访问. 经常使用synchronized关键字修饰同步方法或同步块. 被synchronized修饰的代码块或方法,同一时刻只能被一个线程调用,后来的线程必须等待第一个线程调用该方法结束后才能继续运行.</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>java笔记</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Java集合框架【转】</title>
    <url>/archives/136b1ea2.html</url>
    <content><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>关于_C++标准模板库(Standard Template Library, STL)_的书籍和资料有很多，关于_Java集合框架(Java Collections Framework, JCF)_的资料却很少，甚至很难找到一本专门介绍它的书籍，这给Java学习者们带来不小的麻烦。我深深的不解其中的原因。<strong>虽然JCF设计参考了STL，但其定位不是Java版的STL，而是要实现一个精简紧凑的容器框架</strong>，对STL的介绍自然不能替代对JCF的介绍。 本系列文章主要从<strong>数据结构和算法</strong>层面分析JCF中List, Set, Map, Stack, Queue等典型容器，<strong>结合生动图解和源代码，帮助读者对Java集合框架建立清晰而深入的理解</strong>。本文并不特意介绍Java的语言特性，但会在需要的时候做出简洁的解释。</p>
<a id="more"></a>

<h1 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h1><p>具体内容安排如下：</p>
<ol>
<li><a href="http://www.cnblogs.com/CarpenterLee/p/5414253.html" target="_blank" rel="noopener external nofollow noreferrer">Java Collections Framework概览</a> 对Java Collections Framework，以及Java语言特性做出基本介绍。</li>
<li><a href="http://www.cnblogs.com/CarpenterLee/p/5419880.html" target="_blank" rel="noopener external nofollow noreferrer">Java ArrayList源码剖析</a> 结合源码对_ArrayList_进行讲解。</li>
<li><a href="http://www.cnblogs.com/CarpenterLee/p/5457150.html" target="_blank" rel="noopener external nofollow noreferrer">Java LinkedList源码剖析</a> 结合源码对_LinkedList_进行讲解。</li>
<li><a href="http://www.cnblogs.com/CarpenterLee/p/5468803.html" target="_blank" rel="noopener external nofollow noreferrer">Java ArrayDeque源码剖析</a> 以_AarryDeque_为例讲解_Stack_和_Queue_。</li>
<li><a href="http://www.cnblogs.com/CarpenterLee/p/5503882.html" target="_blank" rel="noopener external nofollow noreferrer">史上最清晰的红黑树讲解（上）</a>和<a href="http://www.cnblogs.com/CarpenterLee/p/5525688.html" target="_blank" rel="noopener external nofollow noreferrer">史上最清晰的红黑树讲解（下）</a> 结合源码对_TreeSet_和_TreeMap_进行讲解。</li>
<li><a href="http://www.cnblogs.com/CarpenterLee/p/5440428.html" target="_blank" rel="noopener external nofollow noreferrer">Java HashSet和HashMap源码剖析</a> 结合源码对_HashSet_和_HashMap_进行讲解。</li>
<li><a href="http://www.cnblogs.com/CarpenterLee/p/5541111.html" target="_blank" rel="noopener external nofollow noreferrer">Java集合框架源码剖析：LinkedHashSet 和 LinkedHashMap</a> 结合源码对_LinkedHashSet_和_LinkedHashMap_进行讲解。</li>
<li><a href="http://www.cnblogs.com/CarpenterLee/p/5488070.html" target="_blank" rel="noopener external nofollow noreferrer">深入理解Java PriorityQueue</a> 结合源码对_PriorityQueue_进行讲解。</li>
<li><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/9-WeakHashMap.md" target="_blank" rel="noopener external nofollow noreferrer">浅谈WeakHashMap</a> 对_WeakHashMap_做出基本介绍。</li>
</ol>
<blockquote>
<p>本文转载自：<a href="https://www.cnblogs.com/CarpenterLee/p/5545987.html" target="_blank" rel="noopener external nofollow noreferrer">https://www.cnblogs.com/CarpenterLee/p/5545987.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>java笔记</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>第一个java程序，从环境配置开始</title>
    <url>/archives/425566db.html</url>
    <content><![CDATA[<blockquote>
<p><strong>先了解几个java术语：</strong> 1、JDK (Java Development Kit)：Java开发工具包 2、JRE (Java Runtime Environment)：运行Java程序的环境 3、JVM (Java Vitual Machine)：Java虚拟机 4、Java SE ( Standard Edition)：用于桌面或简单服务器应用的Java平台 5、Java EE ( Enterprise Edition)：用于复杂服务器应用的Java平台 6、Java ME (Micro Edition)：用于手机或其他小型设备的Java平台</p>
</blockquote>
<hr>
<h3 id="一、java开发环境配置（for-windows）。"><a href="#一、java开发环境配置（for-windows）。" class="headerlink" title="一、java开发环境配置（for windows）。"></a>一、java开发环境配置（for windows）。</h3><p><strong>STEP 1</strong> .下载Java开发工具包（JDK），点击<a href="https://www.oracle.com/java/technologies/javase-jdk8-downloads.html" target="_blank" rel="noopener external nofollow noreferrer">这里</a>到官网下载JDK8。</p>
<h5 id="百度网盘下载链接：https-pan-baidu-com-s-1oAwNVbhvHgs6DE1uLlBXNA-提取码：pj6z"><a href="#百度网盘下载链接：https-pan-baidu-com-s-1oAwNVbhvHgs6DE1uLlBXNA-提取码：pj6z" class="headerlink" title="百度网盘下载链接：https://pan.baidu.com/s/1oAwNVbhvHgs6DE1uLlBXNA 提取码：pj6z"></a>百度网盘下载链接：<a href="https://pan.baidu.com/s/1oAwNVbhvHgs6DE1uLlBXNA" target="_blank" rel="noopener external nofollow noreferrer">https://pan.baidu.com/s/1oAwNVbhvHgs6DE1uLlBXNA</a> 提取码：pj6z</h5><p><strong>STEP 2</strong>. 下载完安装，安装过程一直下一步就ok（记住安装路径，后面要用）。 <strong>STEP 3</strong>. JDK安装完成后. <strong>1、配置系统环境变量</strong> 右击“此电脑”–&gt;”属性”–&gt;”高级系统设置”–&gt;”高级”–&gt;”环境变量”</p>
<ul>
<li><p>在系统变量里新建”JAVA_HOME”变量，变量值为：JDK的安装路径(我的是：C:\Program Files\Java\jdk1.8.0_05)；</p>
</li>
<li><p>找到Path变量（已存在不用新建）添加两个变量值分别是英文句号和%JAVA_HOME%\bin：</p>
<p>.</p>
<p>%JAVA_HOME%\bin</p>
<p>如果不是win10的系统，则在Path的最前面添加：.;%JAVA_HOME%\bin;</p>
</li>
</ul>
<p><strong>classpath配置问题：</strong>如果使用JDK1.5以上的版本，则无需配置classpath，JRE会自动搜索当前路径下的类文件及相关jar文件。 <strong>2、测试是否成功</strong> 命令行中输入（命令行打开方式：win+R，输入cmd，回车）：</p>
<p>java -version</p>
<p>成功界面如下： <img src="https://scanf.top/wp-content/uploads/2020/02/c078b46524c7c3ce365c6d2bdd59d229.png" alt=""></p>
<h3 id="二、第一个Java程序（使用终端）"><a href="#二、第一个Java程序（使用终端）" class="headerlink" title="二、第一个Java程序（使用终端）"></a>二、第一个Java程序（使用终端）</h3><p><strong>STEP 1.</strong> 新建一个文件：hello.java，保存以下代码（注意类名和文件名一致）：</p>
<p>public class hello {<br>    public static void main ( String[] args) {<br>        System.out.println(“hello world!”);<br>    }<br>}</p>
<p><strong>STEP 2</strong>. 打开命令行，工作目录切换到hello.java 所在的目录。 <strong>STEP 3.</strong> 执行：javac hello.java，编译java文件 <strong>STEP 4</strong>. 执行：java hello，运行编译生成的.class文件。 命令行操作步骤如图： <img src="https://scanf.top/wp-content/uploads/2020/02/0b18c1d66f7bf7357c43f81f1ae85ec3.png" alt=""></p>
<h3 id="三、第一个Java程序（使用IDE）"><a href="#三、第一个Java程序（使用IDE）" class="headerlink" title="三、第一个Java程序（使用IDE）"></a>三、第一个Java程序（使用IDE）</h3><p>本次演示使用的IDE是：IntelliJ IDEA <strong>STEP 1.</strong> 新建一个新项目 <img src="https://scanf.top/wp-content/uploads/2020/02/1835155e7e333172beee82ca56d1e72e.png" alt=""> <img src="https://scanf.top/wp-content/uploads/2020/02/4d040e00ac4d5f480f97e40b8c8a7a47.png" alt=""> <strong>STEP 2</strong>. 右击src文件夹，新建一个 Java Class文件。 <img src="https://scanf.top/wp-content/uploads/2020/02/7041b85a181479e78b043df5ccbb7c17.png" alt=""> <img src="https://scanf.top/wp-content/uploads/2020/02/d0017319c971df2d68aa74d09efaf5d9.png" alt=""> <strong>STEP 3</strong>. 写入代码（注意类名和文件名一致）</p>
<p>public class HelloJava {<br>    public static void main ( String args[] ) {<br>        System.out.println(“Hello Java!”);<br>    }<br>}</p>
<p><strong>STEP 4</strong>. 右键，运行，输出结果如下： <img src="https://scanf.top/wp-content/uploads/2020/02/b8d854762ab0eedeb76005f1e083c980.png" alt=""></p>
<hr>
<p>写于2020年2月17日深夜。<strong>武汉加油</strong>！</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>java笔记</tag>
        <tag>java</tag>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程 - TCP</title>
    <url>/archives/7997a0cc.html</url>
    <content><![CDATA[<h1 id="一、-TCP编程"><a href="#一、-TCP编程" class="headerlink" title="一、 TCP编程"></a>一、 TCP编程</h1><h2 id="1-1-了解TCP协议"><a href="#1-1-了解TCP协议" class="headerlink" title="1.1 了解TCP协议"></a>1.1 了解TCP协议</h2><p>TCP（Transmission Control Protocol）是一个面向连接的传输控制协议，可以实现 可靠无差错的双向字节流数据传输。</p>
<h2 id="1-2-TCP在Java中的使用"><a href="#1-2-TCP在Java中的使用" class="headerlink" title="1.2 TCP在Java中的使用"></a>1.2 TCP在Java中的使用</h2><p>Java中使用TCP协议传输数据的过程如下： <a href="https://scanf.top/wp-content/uploads/2020/04/wp_editor_md_dd24c9d659e1b73de9bd82a68347290f.jpg"><img src="https://scanf.top/wp-content/uploads/2020/04/wp_editor_md_dd24c9d659e1b73de9bd82a68347290f.jpg" alt=""></a></p>
<ul>
<li><p>ServerSocket：服务器码头，需要绑定指定端口。用于接收客户端发来的连接请求，服务器接受请求后为该客户端创建新的Socket</p>
</li>
<li><p>Socket：运输通道</p>
</li>
</ul>
<ol>
<li><p>服务器：创建一个ServerSocket，等待连接。</p>
</li>
<li><p>客户机：创建一个Socket，连接到服务器指定端口。</p>
</li>
<li><p>服务器：ServerSocket接到连接，创建一个Socket和客户的Socket建立专线连接，后续，服务器和客户机的对话会在一个单独的线程上运行。</p>
</li>
<li><p>服务器的ServerSocket继续等待连接。</p>
</li>
</ol>
<p><strong>使用TCP协议在计算机间通讯：</strong> 服务器端：</p>
<pre><code>import java.net.*;
import java.io.*;
public class TcpServer
{
    public static void main(String [] args) 
    {
        try
        {
            ServerSocket ss=new ServerSocket(8001); //驻守在8001端口
            Socket s=ss.accept();                   //阻塞，等到有客户端连接上来
            System.out.println(&quot;有一个客户端成功接入&quot; + s.getInetAddress() + &quot;:&quot; +s.getPort());
            InputStream ips=s.getInputStream();     //有人连上来，打开输入流
            OutputStream ops=s.getOutputStream();   //打开输出流
            //同一个通道，服务端的输出流就是客户端的输入流；服务端的输入流就是客户端的输出流
            ops.write(&quot;Hello, Client!&quot;.getBytes());  //输出一句话给客户端</code></pre><p>​<br>                BufferedReader br = new BufferedReader(new InputStreamReader(ips,”UTF-8”));<br>                //从客户端读取一句话<br>                System.out.println(“Client said: “ + br.readLine());</p>
<p>​<br>                ips.close();<br>                ops.close();<br>                s.close();<br>                ss.close();<br>            }<br>            catch(Exception e)<br>            {<br>                e.printStackTrace();<br>            }<br>        }<br>    }</p>
<p>客户端：</p>
<pre><code>import java.net.*;
import java.io.*;

public class TcpClient {
    public static void main(String[] args) {
        try {
            Socket s = new Socket(InetAddress.getByName(&quot;yourServerHostName&quot;), 8001); //需要服务端先开启

            //同一个通道，服务端的输出流就是客户端的输入流；服务端的输入流就是客户端的输出流
            InputStream ips = s.getInputStream();    //开启通道的输入流
            //从来自通道的输入流中读取数据
            BufferedReader brNet = new BufferedReader(new InputStreamReader(ips,&quot;UTF-8&quot;));

            OutputStream ops = s.getOutputStream();  //开启通道的输出流
            DataOutputStream dos = new DataOutputStream(ops);           

            //从运行客户端的系统键盘中读取数据
            BufferedReader brKey = new BufferedReader(new InputStreamReader(System.in,&quot;UTF-8&quot;));
            while (true) 
            {
                String strWord = brKey.readLine();
                if (strWord.equalsIgnoreCase(&quot;quit&quot;))
                {
                    break;
                }
                else
                {
                    System.out.println(&quot;I want to send: &quot; + strWord);
                    dos.writeBytes(strWord + System.getProperty(&quot;line.separator&quot;));

                    System.out.println(&quot;Server said: &quot; + brNet.readLine());
                }

            }

            dos.close();
            brNet.close();
            brKey.close();
            s.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}</code></pre>]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>java笔记</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程 - UDP</title>
    <url>/archives/37145c3c.html</url>
    <content><![CDATA[<h1 id="一、UDP编程"><a href="#一、UDP编程" class="headerlink" title="一、UDP编程"></a>一、UDP编程</h1><h2 id="1-1-UDP基础知识"><a href="#1-1-UDP基础知识" class="headerlink" title="1.1 UDP基础知识"></a>1.1 UDP基础知识</h2><p>UDP（User Datagram Protocol）是面向无连接的用户数据报协议,提供的是不可靠的数据传输服务，但速度快，在较差的网络环境下也能使用。</p>
<h2 id="1-2-UDP在Java中的使用"><a href="#1-2-UDP在Java中的使用" class="headerlink" title="1.2 UDP在Java中的使用"></a>1.2 UDP在Java中的使用</h2><p>在java中使用UDP协议传输数据的过程和相关组件如下： <a href="https://scanf.top/wp-content/uploads/2020/04/wp_editor_md_1ca0dffa630089263e3e55a526934dae.jpg"><img src="https://scanf.top/wp-content/uploads/2020/04/wp_editor_md_1ca0dffa630089263e3e55a526934dae.jpg" alt=""></a></p>
<ul>
<li><p>DatagramSocket：数据报端口，可以形象的理解为数据管道，提供数据传输的管道。</p>
</li>
<li><p>DatagramPacket：数据报包，可以形象的理解为集装箱，提供数据封装的方法。</p>
</li>
</ul>
<p>计算机A向计算机B发送数据，实际上就是计算机A的某个端口，向计算机B的指定端口发送数据。 <strong>使用UDP协议在两个计算机间发送消息：</strong> 现在有计算机A：localhost 和 计算机B：49.234.194.123 计算机A编译运行UdpSend.java程序，代码如下：</p>
<pre><code>import java.net.*;
import java.util.Scanner;
public class UdpSend
{
    public static void main(String [] args) throws Exception
    {
        //申请一个随机的端口
        DatagramSocket ds = new DatagramSocket();

        Scanner input = new Scanner(System.in);
        String content = &quot;&quot;;
        //当content内容不为quit时，持续向接收端发送消息，内容为content
        while(!&quot;quit&quot;.equalsIgnoreCase(content)) {
            System.out.print(&quot;输入消息内容，输入quit叫停接收端：&quot;);
            //更新content内容
            content = input.next();
            //将字符串转换为byte数组
            byte[] buf = content.getBytes();
            //封装一个数据包，包中含有消息内容和目的地
            DatagramPacket dp = new DatagramPacket(buf, 0, buf.length, InetAddress.getByName(&quot;localhost&quot;), 8001);

            System.out.println(&quot;UdpSend:正在发送消息&quot;);
            ds.send(dp);
            System.out.println(&quot;UdpSend:消息发送完成&quot;);
        }
        input.close();
        ds.close();
    }

}</code></pre><p>计算机B编译运行UdpRecv.java程序，代码如下：</p>
<pre><code>import java.net.*;
public class UdpRecv
{
    public static void main(String[] args) throws Exception
    {
        byte[] buff = new byte[1024];
        //占用一个端口，作用：数据通道
        DatagramSocket ds = new DatagramSocket(8001);
        //创建一个数据包，buff装数据。
        DatagramPacket dp = new DatagramPacket(buff, buff.length);

        String recvContent = &quot; &quot;; 
        //接收方一直在8001端口等待接收数据
        while(!&quot;quit&quot;.equalsIgnoreCase(recvContent)) {
            System.out.println(&quot;UdpRecv：等待数据接收&quot;);
            ds.receive(dp);
            System.out.println(&quot;UdpRecv：消息接收完成&quot;);

            //输出数据包中的部分信息
            recvContent = new String(dp.getData(), 0, dp.getLength());
            System.out.println(recvContent + &quot; form:&quot; + dp.getAddress().getHostAddress() + &quot;:&quot; + dp.getPort());
        }
        ds.close();
    }</code></pre><p>​<br>    }</p>
<p><strong>操作步骤：</strong></p>
<ol>
<li>先运行接收端程序，线程将阻塞在端口接收数据的状态，直到端口有发送方传来的数据。当接收端受到的消息内容为quit时，关闭端口，结束程序。</li>
<li>再运行发送端程序。</li>
</ol>
<p><strong>截图演示：</strong> 发送方： <a href="https://scanf.top/wp-content/uploads/2020/04/wp_editor_md_22dc96d10019ab30896fc59db9a75437.jpg"><img src="https://scanf.top/wp-content/uploads/2020/04/wp_editor_md_22dc96d10019ab30896fc59db9a75437.jpg" alt=""></a> 接收方： <a href="https://scanf.top/wp-content/uploads/2020/04/wp_editor_md_7e61ecbde6591cd3b1faa1cc2232211e.jpg"><img src="https://scanf.top/wp-content/uploads/2020/04/wp_editor_md_7e61ecbde6591cd3b1faa1cc2232211e.jpg" alt=""></a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>java笔记</tag>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title>实例化Bean的三种方式</title>
    <url>/archives/da03f5c5.html</url>
    <content><![CDATA[<h2 id="一、对相关概念的了解："><a href="#一、对相关概念的了解：" class="headerlink" title="一、对相关概念的了解："></a>一、对相关概念的了解：</h2><p>bean是应用的主要部分，并由IoC Container组装（assemble）、实例化（instantiate）和管理。 ApplicationContext代表IoC容器，它根据读取的“配置元数据”（Configuration matedata）来获取组装、实例化和管理bean的指令。配置元数据的表示方式有：XML配置文件、注解、Java程序。</p>
<a id="more"></a>

<h2 id="二、实例化bean的方法"><a href="#二、实例化bean的方法" class="headerlink" title="二、实例化bean的方法"></a>二、实例化bean的方法</h2><h3 id="1-用构造函数实例化"><a href="#1-用构造函数实例化" class="headerlink" title="1 用构造函数实例化"></a>1 用构造函数实例化</h3><p>此方法最为简单常用，仅需给出简单的bean类，并配置id即可直接实例化bean。 实例化类：</p>
<pre><code>package com.example.demo.pojo;

public class User {
    public void show(){
        System.out.println(&quot;hello,Spring&quot;);
    }
}</code></pre><p>配置文件：</p>
<pre><code>&lt;bean id=&quot;user&quot; class=&quot;com.example.demo.pojo.User&quot;/&gt;</code></pre><p>测试方法：</p>
<pre><code>public void test3(){
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;service.xml&quot;);
        User user = (User) context.getBean(&quot;user&quot;);
        user.show();
    }</code></pre><p>输出结果：</p>
<pre><code>17:05:50.365 [main] DEBUG org.springframework.context.support.ClassPathXmlApplicationContext - Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@3dd3bcd
17:05:50.488 [main] DEBUG org.springframework.beans.factory.xml.XmlBeanDefinitionReader - Loaded 3 bean definitions from class path resource [service.xml]
17:05:50.518 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &apos;person&apos;
17:05:50.528 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &apos;cat&apos;
17:05:50.567 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &apos;user&apos;
hello,Spring</code></pre><h3 id="2-用静态工厂方法实例化"><a href="#2-用静态工厂方法实例化" class="headerlink" title="2 用静态工厂方法实例化"></a>2 用静态工厂方法实例化</h3><p>该方法较为复杂，实例化的类中需包含一个静态的方法。该方法直接new一个类对象并返回，并在配置文件中声明该bean类，同时指明factory-method，即上述返回类对象的静态方法的名称。 实例化类：</p>
<pre><code>package com.example.demo.pojo;

public class User2 {
    private User2() {}

    public void show(){
        System.out.println(&quot;hello,Spring&quot;);
    }
    public static User2 getInstance(){
        return new User2();
    }
}</code></pre><p>配置文件：</p>
<pre><code>&lt;bean id=&quot;user2&quot; class=&quot;com.example.demo.pojo.User2&quot; factory-method=&quot;getInstance&quot;/&gt;</code></pre><p>测试方法：</p>
<pre><code>public void test4(){
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;service.xml&quot;);
        User2 user2 = (User2) context.getBean(&quot;user2&quot;);
        user2.show();
    }</code></pre><p>输出结果：</p>
<pre><code>17:17:52.576 [main] DEBUG org.springframework.context.support.ClassPathXmlApplicationContext - Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@3dd3bcd
17:17:52.691 [main] DEBUG org.springframework.beans.factory.xml.XmlBeanDefinitionReader - Loaded 4 bean definitions from class path resource [service.xml]
17:17:52.723 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &apos;person&apos;
17:17:52.734 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &apos;cat&apos;
17:17:52.760 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &apos;user&apos;
17:17:52.760 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &apos;user2&apos;
hello,Spring</code></pre><h3 id="3-用实例工厂方法实例化"><a href="#3-用实例工厂方法实例化" class="headerlink" title="3 用实例工厂方法实例化"></a>3 用实例工厂方法实例化</h3><p>该方法更为复杂，通过工厂类中的非静态方法实例化类对象。 实例化类：</p>
<pre><code>package com.example.demo.pojo;

public class User3 {
    public void show(){
        System.out.println(&quot;hello,Spring&quot;);
    }

}</code></pre><p>工厂类：</p>
<pre><code>package com.example.demo.pojo;

public class User3Factory {
    public User3 getUser3(){
        return new User3();
    }
}</code></pre><p>​    </p>
<p>配置文件： 第一个bean标签指明工厂类。第二个bean标签指明实例化类，并说明工厂类和工厂类中的方法。</p>
<pre><code>&lt;bean id=&quot;user3factory&quot; class=&quot;com.example.demo.pojo.User3Factory&quot;/&gt;
&lt;bean id=&quot;user3&quot; factory-bean=&quot;user3factory&quot; factory-method=&quot;getUser3&quot; /&gt;</code></pre><p>测试方法：</p>
<pre><code>public void test5(){
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;service.xml&quot;);
        User3 user3 = (User3) context.getBean(&quot;user3&quot;);
        user3.show();
    }</code></pre><p>输出结果：</p>
<pre><code>17:34:53.967 [main] DEBUG org.springframework.context.support.ClassPathXmlApplicationContext - Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@3dd3bcd
17:34:54.083 [main] DEBUG org.springframework.beans.factory.xml.XmlBeanDefinitionReader - Loaded 6 bean definitions from class path resource [service.xml]
17:34:54.120 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &apos;person&apos;
17:34:54.132 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &apos;cat&apos;
17:34:54.155 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &apos;user&apos;
17:34:54.155 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &apos;user2&apos;
17:34:54.157 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &apos;user3factory&apos;
17:34:54.157 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &apos;user3&apos;
hello,Spring</code></pre><h2 id="另外，如何给相关方法传递参数？？？"><a href="#另外，如何给相关方法传递参数？？？" class="headerlink" title="另外，如何给相关方法传递参数？？？"></a>另外，如何给相关方法传递参数？？？</h2><p>该部分可能涉及了依赖注入的知识，暂且搁置，应该会在后面的文章中体现。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>IoC</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>依赖注入的两种方式</title>
    <url>/archives/620ddfc8.html</url>
    <content><![CDATA[<h2 id="一-什么是依赖注入"><a href="#一-什么是依赖注入" class="headerlink" title="一 什么是依赖注入"></a>一 什么是依赖注入</h2><p>依赖注入是一个过程，通过该过程可以解决对象依赖问题。现假设一个场景，有类A和类B，类A依赖类B，以往在我们实例化类A时，需要先拥有类B的实例化对象，利用这个对象才能完成类A的实例化。现在，类B的实例化任务由IoC容器接管了，我们可以直接获取类A的实例化对象，而无需顾及类B的实例化过程，我们需要做的仅是类A和类B的依赖关系的声明。</p>
<a id="more"></a>

<h2 id="二-依赖注入的两种方式"><a href="#二-依赖注入的两种方式" class="headerlink" title="二 依赖注入的两种方式"></a>二 依赖注入的两种方式</h2><p>有两种依赖注入的方式，其一基于非静态的setter方法，其二基于构造方法，下面列举两个实例。</p>
<h3 id="1-setter-based-DI"><a href="#1-setter-based-DI" class="headerlink" title="1 setter-based DI"></a>1 setter-based DI</h3><p>实例化类和该类的相关依赖：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Person.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.demo.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line">    <span class="keyword">private</span> Car car;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* public Person(Integer id, Cat cat, Car car) &#123;</span></span><br><span class="line"><span class="comment">        this.id = id;</span></span><br><span class="line"><span class="comment">        this.cat = cat;</span></span><br><span class="line"><span class="comment">        this.car = car;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCat</span><span class="params">(Cat cat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cat = cat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.car = car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">catWork</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cat.work();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">carWork</span><span class="params">()</span></span>&#123;</span><br><span class="line">        car.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Cat.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.demo.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"喵喵喵。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Car.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.demo.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"汽车行驶中。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"com.example.demo.pojo.Person"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"car"</span> <span class="attr">ref</span>=<span class="string">"car"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cat"</span> <span class="attr">ref</span>=<span class="string">"cat"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat"</span> <span class="attr">class</span>=<span class="string">"com.example.demo.pojo.Cat"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car"</span> <span class="attr">class</span>=<span class="string">"com.example.demo.pojo.Car"</span>/&gt;</span></span><br></pre></td></tr></table></figure>


<p>测试方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring.xml"</span>);</span><br><span class="line">        Person person = (Person) context.getBean(<span class="string">"person"</span>);</span><br><span class="line">        person.catWork();</span><br><span class="line">        person.carWork();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">21:17:07.766 [main] DEBUG org.springframework.context.support.ClassPathXmlApplicationContext - Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@3dd3bcd</span><br><span class="line">21:17:07.895 [main] DEBUG org.springframework.beans.factory.xml.XmlBeanDefinitionReader - Loaded 3 bean definitions from class path resource [spring.xml]</span><br><span class="line">21:17:07.923 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &#39;person&#39;</span><br><span class="line">21:17:07.968 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &#39;car&#39;</span><br><span class="line">21:17:07.969 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &#39;cat&#39;</span><br><span class="line">喵喵喵。。。</span><br><span class="line">汽车行驶中。。。</span><br></pre></td></tr></table></figure>


<h3 id="2-constructor-based-DI"><a href="#2-constructor-based-DI" class="headerlink" title="2 constructor-based DI"></a>2 constructor-based DI</h3><p>实例化类和该类的相关依赖：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Person.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.demo.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line">    <span class="keyword">private</span> Car car;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Integer id, Cat cat, Car car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.cat = cat;</span><br><span class="line">        <span class="keyword">this</span>.car = car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">catWork</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cat.work();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">carWork</span><span class="params">()</span></span>&#123;</span><br><span class="line">        car.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Cat.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.demo.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"喵喵喵。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Car.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.demo.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"汽车行驶中。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"com.example.demo.pojo.Person"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"java.lang.Integer"</span> <span class="attr">value</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"cat"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"car"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat"</span> <span class="attr">class</span>=<span class="string">"com.example.demo.pojo.Cat"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car"</span> <span class="attr">class</span>=<span class="string">"com.example.demo.pojo.Car"</span>/&gt;</span></span><br></pre></td></tr></table></figure>


<p>测试方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring.xml"</span>);</span><br><span class="line">        Person person = (Person) context.getBean(<span class="string">"person"</span>);</span><br><span class="line">        person.catWork();</span><br><span class="line">        person.carWork();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">21:06:07.375 [main] DEBUG org.springframework.context.support.ClassPathXmlApplicationContext - Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@12d3a4e9</span><br><span class="line">21:06:07.483 [main] DEBUG org.springframework.beans.factory.xml.XmlBeanDefinitionReader - Loaded 3 bean definitions from class path resource [spring.xml]</span><br><span class="line">21:06:07.514 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &#39;person&#39;</span><br><span class="line">21:06:07.525 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &#39;cat&#39;</span><br><span class="line">21:06:07.527 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &#39;car&#39;</span><br><span class="line">喵喵喵。。。</span><br><span class="line">汽车行驶中。。。</span><br></pre></td></tr></table></figure>


<h2 id="三-区别"><a href="#三-区别" class="headerlink" title="三 区别"></a>三 区别</h2><p>两者可以混合使用，可将Constructor-based用于强制性依赖项，Setter-based用于可选性依赖性。可在setter方法上标注<code>@Required</code>注解，使其成为必需依赖项。</p>
<h2 id="四-循环依赖问题"><a href="#四-循环依赖问题" class="headerlink" title="四 循环依赖问题"></a>四 循环依赖问题</h2><p>假设一个会出现循环依赖问题的场景，类A通过构造方法注入类B的实例，类B通过构造方法注入类A的实例。如果你为类A和类B的相互注入而配置了bean，则Spring IoC容器回在运行时检测到循环引用，抛出<code>BeanCurrentlyInCreationException</code>异常，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WARN org.springframework.context.support.ClassPathXmlApplicationContext - Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;a&#39; defined in class path resource [spring.xml]: Cannot resolve reference to bean &#39;b&#39; while setting constructor argument; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;b&#39; defined in class path resource [spring.xml]: Cannot resolve reference to bean &#39;a&#39; while setting constructor argument; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name &#39;a&#39;: Requested bean is currently in creation: Is there an unresolvable circular reference?</span><br></pre></td></tr></table></figure>


<p>解决这个问题的方案是，修改类A和类B的依赖注入方式，从构造方法注入修改为setter注入，实例如下。 相关类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.demo.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> B b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*public A(String name, B b) &#123;</span></span><br><span class="line"><span class="comment">        this.name = name;</span></span><br><span class="line"><span class="comment">        this.b = b;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setB</span><span class="params">(B b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"FROM-A: A.name = "</span> + <span class="keyword">this</span>.name + <span class="string">" B.name = "</span> + b.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//B.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.demo.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> A a;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  public B(String name, A a) &#123;</span></span><br><span class="line"><span class="comment">        this.name = name;</span></span><br><span class="line"><span class="comment">        this.a = a;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(A a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"FROM-B: B.name = "</span> + <span class="keyword">this</span>.name + <span class="string">" A.name = "</span> + a.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"a"</span> <span class="attr">class</span>=<span class="string">"com.example.demo.pojo.A"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"A"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"b"</span> <span class="attr">ref</span>=<span class="string">"b"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"b"</span> <span class="attr">class</span>=<span class="string">"com.example.demo.pojo.B"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"B"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"a"</span> <span class="attr">ref</span>=<span class="string">"a"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring.xml"</span>);</span><br><span class="line">        A a = (A)context.getBean(<span class="string">"a"</span>);</span><br><span class="line">        a.work();</span><br><span class="line">        B b = (B)context.getBean(<span class="string">"b"</span>);</span><br><span class="line">        b.work();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>测试结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10:15:09.428 [main] DEBUG org.springframework.context.support.ClassPathXmlApplicationContext - Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@3dd3bcd</span><br><span class="line">10:15:09.549 [main] DEBUG org.springframework.beans.factory.xml.XmlBeanDefinitionReader - Loaded 2 bean definitions from class path resource [spring.xml]</span><br><span class="line">10:15:09.580 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &#39;a&#39;</span><br><span class="line">10:15:09.620 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &#39;b&#39;</span><br><span class="line">FROM-A: A.name &#x3D; A B.name &#x3D; B</span><br><span class="line">FROM-B: B.name &#x3D; B A.name &#x3D; A</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>DI</tag>
      </tags>
  </entry>
  <entry>
    <title>bean的作用范围</title>
    <url>/archives/eea3a450.html</url>
    <content><![CDATA[<p>了解bean的作用范围：singleton、prototype、request、session、application、websocket</p>
<a id="more"></a>

<hr>
<p>singleton：在spring IoC容器仅存在一个Bean实例，Bean以单例方式存在，bean作用域范围的默认值。</p>
<p>prototype：每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行newXxxBean()。</p>
<p>request：每次HTTP请求都会创建一个新的Bean，该作用域仅适用于web的Spring WebApplicationContext环境。</p>
<p>session：同一个HTTP Session共享一个Bean，不同Session使用不同的Bean。该作用域仅适用于web的Spring WebApplicationContext环境。</p>
<p>application：限定一个Bean的作用域为ServletContext的生命周期。该作用域仅适用于web的Spring WebApplicationContext环境。</p>
<p>websocket：将单个bean定义的作用域限定为WebSocket的生命周期。该作用域仅适用于web的Spring WebApplicationContext环境。</p>
<!-- more -->

<h2 id="一-singleton"><a href="#一-singleton" class="headerlink" title="一 singleton"></a>一 singleton</h2><p>当你将一个bean的<code>scope</code>定义为<code>singleton</code>范围后，Spring IoC容器将为该bean所定义的对象创建一个实例。该单个实例存储在此类单例bean的缓存中，并且对该命名bean的所有后续请求和引用都返回缓存的对象。下图显示了单例作用域如何工作： <a href="https://scanf.top/wp-content/uploads/2020/07/wp_editor_md_1619d0a0724317ea5bf2d6109b1cdcfb.jpg"><img src="https://scanf.top/wp-content/uploads/2020/07/wp_editor_md_1619d0a0724317ea5bf2d6109b1cdcfb.jpg" alt=""></a> 这意味着，如果您在单个Spring容器中为特定类定义一个bean，且将作用范围指明为singleton，则Spring容器将创建该bean定义所定义的类的实例有且只有一个。单例作用域是Spring中的默认作用域。要将bean定义为XML中的单例。 单例案例： <strong>1 来个bean</strong></p>
<pre><code>package com.example.demo.pojo;

public class DemoBean {
    private String msg;

    public String getMsg() {
        System.out.println(&quot;msg = &quot; + msg);
        return msg;
    }

    public void setMsg(String msg) {
        this.msg = msg;
    }
}</code></pre><p><strong>2 bean定义in xml</strong></p>
<pre><code>&lt;bean id=&quot;singletonDemo&quot; class=&quot;com.example.demo.pojo.DemoBean&quot; scope=&quot;singleton&quot;/&gt;</code></pre><p><strong>3 测试方法</strong></p>
<pre><code>@Test
public void test1(){
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    DemoBean demoA = (DemoBean) context.getBean(&quot;singletonDemo&quot;);
    DemoBean demoB = (DemoBean) context.getBean(&quot;singletonDemo&quot;);
    if (demoA == demoB){
        System.out.println(&quot;==&quot;);
    }
}</code></pre><p><strong>4 输出结果</strong></p>
<pre><code>17:55:42.284 [main] DEBUG org.springframework.context.support.ClassPathXmlApplicationContext - Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@3dd3bcd
17:55:42.406 [main] DEBUG org.springframework.beans.factory.xml.XmlBeanDefinitionReader - Loaded 2 bean definitions from class path resource [spring.xml]
17:55:42.430 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &apos;singletonDemo&apos;
==</code></pre><p>测试方法中，获取了两次id为<code>singletonDemo</code>的bean定义的对象，分别为demoA和demoB，然后对这两个对象做出==判断，单元测试结果输出如上，说明两次获得的对象为同一个。</p>
<h2 id="二-prototype"><a href="#二-prototype" class="headerlink" title="二 prototype"></a>二 prototype</h2><p>当一个bean的作用域为<code>prototype</code>，表示一个bean定义对应多个对象实例。声明为<code>prototype</code>作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。 <code>prototype</code>是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。 根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。 下图说明了Spring原型范围： <a href="https://scanf.top/wp-content/uploads/2020/07/wp_editor_md_f8c376ab883e6cb8d08d89bac9ebf7f6.jpg"><img src="https://scanf.top/wp-content/uploads/2020/07/wp_editor_md_f8c376ab883e6cb8d08d89bac9ebf7f6.jpg" alt=""></a> <strong>单例案例：</strong> <strong>1 来个bean</strong></p>
<pre><code>package com.example.demo.pojo;

public class DemoBean {
    private String msg;

    public String getMsg() {
        System.out.println(&quot;msg = &quot; + msg);
        return msg;
    }

    public void setMsg(String msg) {
        this.msg = msg;
    }
}</code></pre><p><strong>2 bean定义in xml</strong></p>
<pre><code>&lt;bean id=&quot;prototypeDemo&quot; class=&quot;com.example.demo.pojo.DemoBean&quot; scope=&quot;prototype&quot;/&gt;</code></pre><p><strong>3 测试方法</strong></p>
<pre><code>@Test
public void test1(){
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    DemoBean demoA = (DemoBean) context.getBean(&quot;prototypeDemo&quot;);
    DemoBean demoB = (DemoBean) context.getBean(&quot;prototypeDemo&quot;);
    if (demoA == demoB){
        System.out.println(&quot;==&quot;);
    }else{
        System.out.println(&quot;!=&quot;);
    }
}</code></pre><p><strong>4 输出结果</strong></p>
<pre><code>17:59:20.579 [main] DEBUG org.springframework.context.support.ClassPathXmlApplicationContext - Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@3dd3bcd
17:59:20.694 [main] DEBUG org.springframework.beans.factory.xml.XmlBeanDefinitionReader - Loaded 2 bean definitions from class path resource [spring.xml]
17:59:20.723 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean &apos;singletonDemo&apos;
!=</code></pre><p>测试方法中，获取了两次id为<code>prototypeDemo</code>的bean定义的对象，分别为demoA和demoB，然后对这两个对象做出==判断，单元测试结果输出如上，说明两次获得的对象不是同一个。 <strong><em>继续阅读，你需要了解Spring官方给出的如下提示：</em></strong></p>
<blockquote>
<p>The <code>request</code>, <code>session</code>, <code>application</code>, and <code>websocket</code> scopes are available only if you use a web-aware Spring <code>ApplicationContext</code> implementation (such as <code>XmlWebApplicationContext</code>). If you use these scopes with regular Spring IoC containers, such as the <code>ClassPathXmlApplicationContext</code>, an <code>IllegalStateException</code> that complains about an unknown bean scope is thrown.</p>
</blockquote>
<p>这意味着，如果你试图用常规的Spring IoC容器（例如<code>ClassPathXmlApplicationContext</code>）来装载上述作用范围的bean，将会抛出<code>IllegalStateException</code>异常来说明使用了未知的作用域。你应该使用<code>XmlWebApplicationContext</code>容器代替。</p>
<h2 id="三-request"><a href="#三-request" class="headerlink" title="三 request"></a>三 request</h2><p>请求作用域参考如下的Bean定义</p>
<pre><code>&lt;bean id=&quot;loginAction&quot; class=&quot;com.foo.LoginAction&quot; scope=&quot;request&quot;/&gt;</code></pre><p>Spring容器会在每次用到loginAction来处理每个HTTP请求的时候都会创建一个新的LoginAction实例。也就是说，loginActionBean的作用域是HTTP Request级别的。  当http请求调用作用域为request的bean的时候，每增加一个HTTP请求，Spring就会创建一个新的bean，在请求处理完成之后便及时销毁这个bean。开发者可以随意改变实例的状态，因为通过loginAction请求来创建的其他实例根本看不到开发者改变的实例状态，所有创建的Bean实例都是根据独立的请求来的。</p>
<h2 id="四-session"><a href="#四-session" class="headerlink" title="四 session"></a>四 session</h2><p>会话作用域参考如下的Bean定义</p>
<pre><code>&lt;bean id=&quot;userPreferences&quot; class=&quot;com.foo.UserPreferences&quot; scope=&quot;session&quot;/&gt;</code></pre><p>Spring容器会在每次调用到userPreferences时，在一个单独的HTTP会话周期来创建一个新的UserPreferences实例。换言之，userPreferencesBean的作用域是HTTP Session级别的。 Session中所有http请求共享同一个请求的bean实例。Session结束后就销毁bean。 在request-scoped作用域的Bean上，开发者可以随意的更改实例的状态。同样，使用从同一个userPreferences bean定义创建的其他HTTP Session实例在看不到不是自己的内部状态的修改，因为他们是单个的HTTP会话。每个Session请求都会创建新的userPreferences实例，所以开发者更改一个Bean的状态，对于其他的Bean仍然是不可见的。</p>
<h2 id="五-application"><a href="#五-application" class="headerlink" title="五 application"></a>五 application</h2><p>全局作用域参考如下的Bean定义</p>
<pre><code>&lt;bean id=&quot;appPreferences&quot; class=&quot;com.foo.AppPreferences&quot; scope=&quot;application&quot;/&gt;</code></pre><p>Spring容器会在整个web应用范围使用到appPreferences的时候创建一个新的AppPreferences的实例。也就是说，appPreferencesBean是在ServletContext级别的，作为常规的ServletContext属性。这种作用域在一些程度上来说和Spring的单例作用域相似，但是也有如下不同之处： 1.application作用域是每个ServletContext中包含一个，而不是每个SpringApplicationContext之中包含一个（某些应用中可能包含不止一个ApplicationContext）。 2.application作用域仅仅作为ServletContext的属性可见，单例Bean是ApplicationContext可见。 接下来再来简单的学习下在Spring当中如何自定义作用域： 在Spring 2.0中，Spring的Bean作用域机制是可以扩展的，这意味着，你不仅可以使用Spring提供的预定义Bean作用域，还可以定义自己的作用域，甚至重新定义现有的作用域（不提倡这么做，而且你不能覆盖内置的singleton和prototype作用域） 本文部分参考了：<a href="https://blog.csdn.net/kongmin_123/article/details/82048392" target="_blank" rel="noopener external nofollow noreferrer" title="https://blog.csdn.net/kongmin_123/article/details/82048392">https://blog.csdn.net/kongmin_123/article/details/82048392</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>lifecycle</tag>
        <tag>scope</tag>
      </tags>
  </entry>
  <entry>
    <title>初识控制反转（IoC）与依赖注入（DI）</title>
    <url>/archives/9c51ba7b.html</url>
    <content><![CDATA[<p>文章链接：<a href="https://www.jianshu.com/p/07af9dbbbc4b" target="_blank" rel="noopener external nofollow noreferrer" title="https://www.jianshu.com/p/07af9dbbbc4b">https://www.jianshu.com/p/07af9dbbbc4b</a> 本文有助于对控制反转（Inversion of Control）和依赖注入（Dependency Injection）基本概念的理解。并举例说明了使用IoC Container解决的生产问题。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>IoC</tag>
        <tag>Spring</tag>
        <tag>DI</tag>
      </tags>
  </entry>
  <entry>
    <title>在MyBatis中使用Log4j输出日志</title>
    <url>/archives/9a61816b.html</url>
    <content><![CDATA[<h2 id="一、指定MyBatis的日志工具"><a href="#一、指定MyBatis的日志工具" class="headerlink" title="一、指定MyBatis的日志工具"></a>一、指定MyBatis的日志工具</h2><p>在 MyBatis 配置文件 mybatis-config.xml 里面添加一项 setting 来选择其它日志实现。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"LOG4J"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>注意，settings标签在configuration标签中的位置，应当符合当前xml文件的约束。</p>
<blockquote>
<p>The content of element type “configuration” must match “(properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?)”.</p>
</blockquote>
<h2 id="二、导入log4j相关依赖"><a href="#二、导入log4j相关依赖" class="headerlink" title="二、导入log4j相关依赖"></a>二、导入log4j相关依赖</h2><ul>
<li><p>maven项目，在pom.xml文件中添加以下坐标</p>
<dependency>
     <groupId>log4j</groupId>
     <artifactId>log4j</artifactId>
     <version>1.2.17</version>
</dependency>
</li>
<li><p>其他项目，导入log4j的jar包，可在 <a href="https://logging.apache.org/log4j/2.x/download.html" target="_blank" rel="noopener external nofollow noreferrer" title="log4j">log4j</a> 网站下载</p>
<a id="more"></a>

</li>
</ul>
<h2 id="三、配置log4j的属性文件"><a href="#三、配置log4j的属性文件" class="headerlink" title="三、配置log4j的属性文件"></a>三、配置log4j的属性文件</h2><p>在应用的类路径中创建一个名为 log4j.properties 的文件，文件的具体内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 全局日志配置</span><br><span class="line">log4j.rootLogger&#x3D;ERROR, stdout</span><br><span class="line"># MyBatis 日志配置</span><br><span class="line">log4j.logger.org.mybatis.example.BlogMapper&#x3D;TRACE</span><br><span class="line"># 控制台输出</span><br><span class="line">log4j.appender.stdout&#x3D;org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern&#x3D;%5p [%t] - %m%n</span><br></pre></td></tr></table></figure>


<p>上述配置将使 Log4J 详细打印 org.mybatis.example.BlogMapper 的日志，对于应用的其它部分，只打印错误信息。 为了实现更细粒度的日志输出，你也可以只打印特定语句的日志。以下配置将只打印语句 selectBlog 的日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log4j.logger.org.mybatis.example.BlogMapper.selectBlog&#x3D;TRACE</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>mybatis</tag>
        <tag>log4j</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis自定义类型处理器TypeHandler</title>
    <url>/archives/ed6def66.html</url>
    <content><![CDATA[<blockquote>
<p>MyBatis 在设置预处理语句（PreparedStatement）中的参数或从结果集中取出一个值时， 都会用类型处理器将获取到的值以合适的方式转换成 Java 类型。</p>
</blockquote>
<p>如果你试图直接将java对象设置为预处理语句PreparedStatement的参数。这样做，在执行sql语句的时候会出现一个问题，java类型的数据如何与数据库类型兼容。对此MyBatis提供了类型处理器，并且实现了一些常用类型的转换。<a id="more"></a>可点击<a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers" target="_blank" rel="noopener external nofollow noreferrer" title="这里">这里</a>查看。 你可以重写已有的类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。 具体做法为：实现 org.apache.ibatis.type.TypeHandler 接口， 或继承一个很便利的类 org.apache.ibatis.type.BaseTypeHandler， 并且可以（可选地）将它映射到一个 JDBC 类型。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ExampleTypeHandler.java</span></span><br><span class="line"><span class="meta">@MappedJdbcTypes</span>(JdbcType.VARCHAR)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleTypeHandler</span> <span class="keyword">extends</span> <span class="title">BaseTypeHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, String parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ps.setString(i, parameter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getNullableResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rs.getString(columnName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getNullableResult</span><span class="params">(ResultSet rs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rs.getString(columnIndex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getNullableResult</span><span class="params">(CallableStatement cs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cs.getString(columnIndex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-config.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">"org.mybatis.example.ExampleTypeHandler"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>mybatis</tag>
        <tag>TypeHandler</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring底层原理之控制反转-初探SSM系列</title>
    <url>/archives/f7ce96ca.html</url>
    <content><![CDATA[<p>本文介绍了：IoC（ Inversion of Control ）的一些概念，与及从IoC容器中获取一个对象的过程。</p>
<a id="more"></a>

<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h3 id="1-1-控制反转"><a href="#1-1-控制反转" class="headerlink" title="1.1 控制反转"></a>1.1 控制反转</h3><p>控制反转 IoC<br>假设一个场景，现有类A和类B，类A依赖类B，即类A中的方法需要引用类B中的相关属性或方法。初始化类A时需要先初始化类B。现在，将类B初始化的工作转交给IoC容器来完成，这样一个过程就是控制反转。即，你设计好的对象由IoC容器管理，而不需要传统地在类内部进行控制。</p>
<h3 id="1-2-依赖注入"><a href="#1-2-依赖注入" class="headerlink" title="1.2 依赖注入"></a>1.2 依赖注入</h3><p>依赖注入 Dependency Injection（DI）<br>在上面的场景中，类B是类A的依赖。初始化类A时，需要将类B的对象注入到类A中，这就是注入依赖的过程。</p>
<h2 id="二、从IoC容器中获取对象的过程"><a href="#二、从IoC容器中获取对象的过程" class="headerlink" title="二、从IoC容器中获取对象的过程"></a>二、从IoC容器中获取对象的过程</h2><h3 id="2-1-主要的技术"><a href="#2-1-主要的技术" class="headerlink" title="2.1 主要的技术"></a>2.1 主要的技术</h3><p>（1）XML解析：读取xml文件中的信息到Java程序中。<br>（2）工厂模式<br>（3）反射机制：IoC容器通过反射机制创建对象，从配置bean的xml文件中读取类名，再根据类名来初始化一个对象。</p>
<h3 id="2-2-获取对象"><a href="#2-2-获取对象" class="headerlink" title="2.2 获取对象"></a>2.2 获取对象</h3><p>（1）编辑XML配置文件，指明需要创建的对象。该工作由自己完成。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--beans.xml--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dao"</span> <span class="attr">class</span>=<span class="string">"com.example.UserDao"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>（2）创建工厂类，该工厂类中包含创建指定对象的静态方法，该工作由框架负责。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class UserFactory&#123;</span><br><span class="line">	<span class="function">Public <span class="keyword">static</span> UserDao <span class="title">getDao</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">/* 解析配置bean的xml文件，获取相关类名 */</span></span><br><span class="line">		String ClassName = <span class="string">"从xml文件中获取"</span>;</span><br><span class="line">		Class cls = Class.forName(ClassName);</span><br><span class="line">		<span class="keyword">return</span> cls.newInstance();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述工作是由框架负责实现的，我们实际获取对象是通过<code>ApplicationContext</code>接口来获取的，我们可以把它理解为IoC容器，我们在xml中配置好的bean都有它类负责管理。</p>
<p>另外需要了解的是：默认情况下，当程序启动后，IoC容器正常的初始化完成，<code>beans.xml</code>中指明的bean同样都会初始化完成，用户可以直接通过<code>getBean</code>方法获取相关对象，不需要再初始化对象，这样就加快了服务响应速度。对于一些很少用到的对象，你可以在xml文件中为单个bean配置<code>Lazy-init</code>属性，从而实现临时创建该对象，避免资源的浪费；同样地，基于BeanFactory的IoC容器，加载配置文件时不创建对象，在获取对象时才创建对象。</p>
<p>我们可以像这样获取beans.xml中指明的bean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据类路径下的xml文件，创建一个IoC容器，该容器中包含指明的类对象。</span></span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">UserDao dao = context.getBean(<span class="string">"dao"</span>, UserDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>初探SSM系列</category>
      </categories>
      <tags>
        <tag>初探SSM,Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>使用嵌套循环，按照指定格式打印字母（一）</title>
    <url>/archives/4d8caefc.html</url>
    <content><![CDATA[<p>设计程序，使用嵌套循环，按照以下格式打印字母：</p>
<p>A<br>BC<br>DEF<br>GHIJ<br>KLMNO<br>PQRSTU</p>
<h3 id="程序实现："><a href="#程序实现：" class="headerlink" title="程序实现："></a>程序实现：</h3><p>#include&lt;stdio.h&gt;</p>
<p>int main( void )<br>{<br>    int hang,fuhao;//行，符号<br>    char fu[22]=”ABCDEFGHIJKLMNOPQRSTU”;</p>
<pre><code>for(hang=1;hang&lt;=6;hang++)//控制换行
{
    for(fuhao=1+(hang\*hang-hang)/2;fuhao&lt;=(hang+hang\*hang)/2;fuhao++)//控制字母打印
    {
        printf(&quot;%c&quot;,fu\[fuhao-1\]);
     } 
     printf(&quot;\\n&quot;);//换行
}</code></pre><p>}</p>
<h3 id="设计思路："><a href="#设计思路：" class="headerlink" title="设计思路："></a>设计思路：</h3><p>给字符串”ABCDEFGHIJKLMNOPQRSTU”中的所有字母从1到21排序。</p>
<h4 id="第一步：先确定每行首字母的序号"><a href="#第一步：先确定每行首字母的序号" class="headerlink" title="第一步：先确定每行首字母的序号"></a>第一步：先确定每行首字母的序号</h4><p>A:1 B:2 D:4 G:7 K:11 P:16 可以看出每行首字母序号的差值为一个递增数列，所以我们可以把每行首字母的序号的通式表达出来。 第n行首字母序号为an（n代表程序中的变量hang） a2-a1=1 a3-a2=2 a4-a3=3 …… an-an-1=n-1 累加得出：an=1+n(n-1)/2 即每行首字母的序号的通式为：an=1+n(n-1)/2</p>
<h4 id="第二步：确定各行有几个字母"><a href="#第二步：确定各行有几个字母" class="headerlink" title="第二步：确定各行有几个字母"></a>第二步：确定各行有几个字母</h4><p>可以看出，各行的字母数等于各行所在行序，即第一行一个字母，第二行两个字母，第n行n个字母。 用bn表示第n行的字母数，那么bn=n(n+1)/2（n代表程序中的变量hang）</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>先确定各行首字母是哪个，在确定各行有几个字母。</p>
]]></content>
      <categories>
        <category>其他</category>
        <category>编程练习</category>
      </categories>
      <tags>
        <tag>C/C++练习</tag>
        <tag>for</tag>
        <tag>嵌套循环</tag>
      </tags>
  </entry>
  <entry>
    <title>使用嵌套循环，按照指定格式打印字母（二）</title>
    <url>/archives/7d9a4224.html</url>
    <content><![CDATA[<p>编写一个程序，提示用户输入大写字母。使用嵌套循环以下面金字塔型的格式打印字母：</p>
<pre><code>A</code></pre><p>   ABA<br>  ABCBA<br> ABCDCBA<br>ABCDEDCBA</p>
<h3 id="程序实现："><a href="#程序实现：" class="headerlink" title="程序实现："></a>程序实现：</h3><p>#include&lt;stdio.h&gt;<br>int main( void )<br>{<br>    char letter[27];<br>    int wrap,letter_element,space;//换行，字母数组元素，空格<br>    int letter_element_after;//后半部分字母的数组下标<br>    int letter_element_before;//前半部分字母的数组下标 </p>
<pre><code>printf(&quot;请输入大写字母（输入格式：ABCDE），最后回车确认：&quot;);
for(letter\_element=0;;letter\_element++){
    scanf(&quot;%c&quot;,&amp;letter\[letter\_element\]);
    if(letter\[letter\_element\]==&apos;\\n&apos;)
    break;
}

for(wrap=1;wrap&lt;=letter\_element;wrap++){

    for(space=wrap;space&lt;letter\_element;space++){
        printf(&quot; &quot;);//打印空格 
    }
    for(letter\_element\_before=0;letter\_element\_before&lt;wrap;letter\_element\_before++){
        printf(&quot;%c&quot;,letter\[letter\_element\_before\]); //打印前半部分字母 
    } 
    for(letter\_element\_after=letter\_element\_before-2;letter\_element\_after&gt;=0;letter\_element\_after--){
        printf(&quot;%c&quot;,letter\[letter\_element\_after\]);//打印后半部分字母 
    }
    printf(&quot;\\n&quot;);
} 

return 0;</code></pre><p>}</p>
<h3 id="设计思路："><a href="#设计思路：" class="headerlink" title="设计思路："></a>设计思路：</h3><p>这是一个略微复杂的输入输出的程序。用户可以告诉程序要处理哪些字母，并按照程序给定的方式结束输入过程。程序将用户输入的字母按照一定的方式进行处理输出。</p>
<h3 id="程序解读："><a href="#程序解读：" class="headerlink" title="程序解读："></a>程序解读：</h3><h4 id="第一步：输入阶段"><a href="#第一步：输入阶段" class="headerlink" title="第一步：输入阶段"></a>第一步：输入阶段</h4><p>输入字母，写入数组。例如输入：ABCDE加回车换行，这是一个字符串，而scanf中的转换说明是字符%c，第一次scanf只把A写入到letter[0]中，将剩余的BCDE和换行符放到缓冲区，for循环中会将剩下的字符一个一个写入数组中相应的位置，并最后遇到换行符“\n”时，if语句会通过break结束for循环。</p>
<h4 id="第二步：输出阶段"><a href="#第二步：输出阶段" class="headerlink" title="第二步：输出阶段"></a>第二步：输出阶段</h4><p>if中的break将执行带出输入过程，进入另一些for循环进行输出处理。第二个for控制换行，第三个for打印空格，第四个for打印每行中前半部分的字母，第五个for打印每行中后半部分字母。其中第三、四、五个循环嵌套在第二个for循环中。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>程序总体流程为：输入，输出（从左到右：一个字符一个字符输出；从上到下：一行一行输出）</p>
]]></content>
      <categories>
        <category>其他</category>
        <category>编程练习</category>
      </categories>
      <tags>
        <tag>C/C++练习</tag>
        <tag>for循环</tag>
      </tags>
  </entry>
  <entry>
    <title>使用指针在函数间通信</title>
    <url>/archives/20fd2522.html</url>
    <content><![CDATA[<h3 id="一、初识指针"><a href="#一、初识指针" class="headerlink" title="一、初识指针"></a>一、初识指针</h3><p>指针是一个值为内存地址的变量（或数据对象）。正如int类型变量的值是整数，指针变量的值是地址。</p>
<h3 id="二、地址运算符-amp-和"><a href="#二、地址运算符-amp-和" class="headerlink" title="二、地址运算符&amp;和*"></a>二、地址运算符&amp;和*</h3><h4 id="地址运算符：-amp"><a href="#地址运算符：-amp" class="headerlink" title="地址运算符：&amp;"></a>地址运算符：&amp;</h4><p>一般注解：后跟一个变量名时，&amp;给出该变量的地址。 示例：&amp;test表示变量test的地址</p>
<h4 id="地址运算符："><a href="#地址运算符：" class="headerlink" title="地址运算符：*"></a>地址运算符：*</h4><p>一般注解：后跟一个指针名或地址时，*给出存储在指针指向地址的值。 示例： test=1； ptr=&test;//指向test的指针 num=*ptr;//把ptr指针指向的地址上的值赋给num 最终结果是将test值1赋给num。</p>
<h3 id="三、声明指针"><a href="#三、声明指针" class="headerlink" title="三、声明指针"></a>三、声明指针</h3><p>声明指针变量时必须指定指针所指向变量的类型，因为不同的变量类型占用不同的存储空间，即使占用的存储空间相同，存储的数据也可能不同。一些指针的声明示例如下： int * pi;    //pi是指向int类型变量的指针 char * pc, * pd;    //pc和pd都是是指向char类型变量的指针 其中星号（*）表面声明的变量是一个指针。 <em>注：*和指针名之间的变量可有可无。通常，人们在声明时使用空格，在解引用变量时省略空格。</em></p>
<h3 id="四、使用指针在函数间通信"><a href="#四、使用指针在函数间通信" class="headerlink" title="四、使用指针在函数间通信"></a>四、使用指针在函数间通信</h3><p>我们知道函数中retrun语句只能返回一个数值，当被调用函数需要向调用函数传递多个数值时，就要使用指针。 如下程序演示了，使用指针在两函数中通信，交换两整数的值：</p>
<p>#include&lt;stdio.h&gt;</p>
<p>void swap(int * a,int * b);<br>int main ( void )<br>{<br>    int x=5,y=10;<br>    printf(“原本：x=%d，y=%d\n”,x,y);<br>    swap(&amp;x,&amp;y);//将x，y的地址传给swap函数<br>    printf(“现在：x=%d，y=%d\n”,x,y);</p>
<pre><code>return 0;</code></pre><p>}<br>void swap(int * a,int * b)<br>{<br>    int temp;<br>    temp=*a;//temp获取指针a所指向地址（&amp;x）的值<br>    *a=*b;<br>    *b=temp;<br>}</p>
<p>main函数把需要处理的变量的地址发送给swap函数，swap函数根据相应的地址影响变量。</p>
]]></content>
      <categories>
        <category>其他</category>
        <category>编程练习</category>
      </categories>
      <tags>
        <tag>C/C++笔记</tag>
        <tag>指针</tag>
        <tag>地址运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>在for循环中使用数组，数据写入、输出、求平均、求最值</title>
    <url>/archives/caeca60a.html</url>
    <content><![CDATA[<h3 id="完整代码："><a href="#完整代码：" class="headerlink" title="完整代码："></a>完整代码：</h3><p>#include&lt;stdio.h&gt;</p>
<p>int main( void )<br>{<br>    int size,i;<br>    int sum=0;//数据求和<br>    float average;//数据平均值<br>    int pre_max,pre_more_max,max;<br>    int pre_min,pre_more_min,min;</p>
<pre><code>printf(&quot;请确定数组的长度：&quot;);
scanf(&quot;%d&quot;,&amp;size);

int grade\[size\];//定义一个size长度的数组 

printf(&quot;请输入%d个整数：&quot;,size);
for(i=0;i&lt;size;i++)
{
    scanf(&quot;%d&quot;,&amp;grade\[i\]);//读取size个分数 
}

printf(&quot;\\n&quot;);

for(i=0;i&lt;size;i++)
{
    printf(&quot;grade\[%d\]==%d\\n&quot;,i,grade\[i\]);//输出size个分数 
 } 
for(i=0;i&lt;size;i++)
{
    sum=sum+grade\[i\]; 
}
    printf(&quot;\\n数组中所有元素的和为：%d&quot;,sum); 
average = (float)sum / size; 
printf(&quot;\\n数组中所有元素的平均数为：%.2f&quot;,average);

if(grade\[0\]-grade\[1\]&gt;0){//确定数组中前两个数的较大值和较小值 
    pre\_max=grade\[0\];
    pre\_min=grade\[1\];
}
else{
    pre\_max=grade\[1\];
    pre\_min=grade\[0\];
}
for(i=2;i&lt;size;i++)//取最大值 
{
    if(pre\_max-grade\[i\]&gt;0){//左边的数大于右边的数 
        pre\_more\_max=pre\_max;
    }
    else{//左边的数小于等于右边的数，更大值为右边的数，并更新pre\_max 
        pre\_more\_max=pre\_max=grade\[i\];
    }
    max=pre\_more\_max;
}
for(i=2;i&lt;size;i++)//取最小值 
{
    if(pre\_min-grade\[i\]&lt;0){
        pre\_more\_min=pre\_min;
    }
    else{
        pre\_more\_min=pre\_min=grade\[i\];
    }
    min=pre\_more\_min;
}
printf(&quot;\\n数组中最大的数是：%d&quot;,max);
printf(&quot;\\n数组中最小的数是：%d&quot;,min);</code></pre><p>​<br>    return 0;<br>}</p>
<h3 id="程序解读："><a href="#程序解读：" class="headerlink" title="程序解读："></a>程序解读：</h3><p>scanf数组长度为size，定义size长度的数组，scanf输入size个整数，for循环遍历整个数组，输出所有数据。再用for循环求和，求平均数时需要注意，average极有可能是小数，所以给average赋值时需要将int类型的sum转换成浮点数类型，以确保数据类型匹配。 接下来求数组中的最大值和最小值。实现思路：数组中从左往右，两两比较，得出较大值，较大值与后面的数据比较，得出更大值或更小值，直到与最后一个数据对比。最小值的求法同理。</p>
<h3 id="输入输出示例："><a href="#输入输出示例：" class="headerlink" title="输入输出示例："></a>输入输出示例：</h3><p>请确定数组的长度：7<br>1 2 2 3 3 7 7</p>
<p>grade[0]==1<br>grade[1]==2<br>grade[2]==2<br>grade[3]==3<br>grade[4]==3<br>grade[5]==7<br>grade[6]==7</p>
<p>数组中所有元素的和为：25<br>数组中所有元素的平均数为：3.57<br>数组中最大的数是：7<br>数组中最小的数是：1</p>
]]></content>
      <categories>
        <category>其他</category>
        <category>编程练习</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>C/C++练习</tag>
        <tag>for</tag>
      </tags>
  </entry>
  <entry>
    <title>已知一个增序顺序表，插入一个新元素后，使其仍然有序</title>
    <url>/archives/6e74351d.html</url>
    <content><![CDATA[<h3 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a>算法思想：</h3><ul>
<li>初始化一个数据元素为增序的数组num。</li>
<li>读入需要插入的数据（整数），保存到x，要求使变量x保存规定的数据类型。</li>
<li>I从0开始，满足条件i≤strlen(num)-1并且flag！=1，循环执行一下步骤，表示x未与数组中的元素比较完，且未找到合适的插入位置。<ol>
<li>如果x &gt;= num[i] &amp;&amp; x &lt;= num[i+1] || x &lt;= num[0] || x &gt;= num[num_len-1]</li>
<li>满足a步骤的如果后，再如果x &gt;= num[num_len-1]，那么i=num_len-1</li>
<li>满足a步骤的如果后，再如果x &lt;= num[0]，那么i=-1</li>
<li>满足a步骤的如果后，将i+1位置到num_len-1位置的元素全部向后移动一个位置。</li>
<li>将新元素存储到num[i+1]</li>
<li>flag置为1，表示程序已经找到了合适的插入位置，使外层for循环及时结束。</li>
</ol>
</li>
<li>遍历输出num</li>
</ul>
<h3 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h3><p>#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br>int main ( void )<br>{<br>    int num[] = {1,2,4,6,8,10,12,14,16};//一个数据元素为增序的顺序表（数组）<br>    int i,x=0,n = 0,flag = 0,num_len=sizeof(num)/4; </p>
<pre><code>while (printf(&quot;请输入需要插入的整数：&quot;) &amp;&amp; scanf(&quot;%d&quot;,&amp;x) != 1)
getchar();//清楚缓冲区中多余的字符（换行符）
for  ( i = 0; i &lt;= num\_len-1 &amp;&amp; flag != 1; i++ )
{
    if ( x &gt;= num\[i\] &amp;&amp; x &lt;= num\[i+1\] || x &lt;= num\[0\] || x &gt;= num\[num\_len-1\] )//找到了需要插入的位置i+1 
    {
        if(x &gt;= num\[num\_len-1\]) i = num\_len-1;
        if(x &lt;= num\[0\]) i = -1;
        for ( n = num\_len; n &gt;= i+2; n-- )
        {
            num\[n\] = num\[n-1\];
        }
        num\[i+1\] = x;//i+1上的位置放置新元素 
        flag = 1;//已找到插入位置的标志,使外层for循环及时结束 
    }
}
for ( i = 0; i &lt;= num\_len; i++ )//遍历输出插入新元素后的顺序表 
{
    printf(&quot;%d &quot;,num\[i\]);
}
return 0;</code></pre><p>}</p>
]]></content>
      <categories>
        <category>其他</category>
        <category>编程练习</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>顺序表插入</tag>
      </tags>
  </entry>
  <entry>
    <title>全局变量在多个c文件中公用的方法</title>
    <url>/archives/afe73244.html</url>
    <content><![CDATA[<h3 id="一、项目文件结构："><a href="#一、项目文件结构：" class="headerlink" title="一、项目文件结构："></a>一、项目文件结构：</h3><p><img src="https://scanf.top/wp-content/uploads/2019/10/QQ%E6%88%AA%E5%9B%BE20191002202138-300x209.png" alt=""></p>
<h3 id="二、个文件代码："><a href="#二、个文件代码：" class="headerlink" title="二、个文件代码："></a>二、个文件代码：</h3><p>//main.c<br>#include&lt;stdio.h&gt;<br>#include”diy.h”</p>
<p>int num = 100;//定义了一个全局变量<br>int main ( void )<br>{</p>
<p>  printf(“From main.c:%d\n”,num);<br>  fuc();</p>
<p>  return 0;<br>}</p>
<p>//diy.h<br>int fuc();</p>
<p>//diy.c<br>#include &lt;stdio.h&gt;<br>#include “diy.h”<br>int fuc()<br>{<br>  extern int num;//声明，num引用外部的变量<br>  printf(“From  diy.c:%d”,num);<br>}</p>
<h3 id="三、相关说明："><a href="#三、相关说明：" class="headerlink" title="三、相关说明："></a>三、相关说明：</h3><p>变量定义和变量声明的区别，变量定义使用“数据类型+变量名称”的形式，编译器需要给他分配内存单元的；而变量声明使用“extern 变量类型+变量名称”的形式，是告诉编译器我这个变量将在其他外部c文件中定义，我这里只是在外部用它。编译器就不给他分配内存空间，而等到真正遇到变量定义的时候再给他分配内存空间。</p>
]]></content>
      <categories>
        <category>其他</category>
        <category>编程练习</category>
      </categories>
      <tags>
        <tag>C/C++笔记</tag>
        <tag>全局变量</tag>
      </tags>
  </entry>
  <entry>
    <title>用C程序将图书信息写入文件</title>
    <url>/archives/37ff2814.html</url>
    <content><![CDATA[<h3 id="程序设计思路："><a href="#程序设计思路：" class="headerlink" title="程序设计思路："></a>程序设计思路：</h3><p><img src="https://scanf.top/wp-content/uploads/2019/10/56937a30607fb606b3f6b4d9b9c6f832.png" alt=""></p>
<h3 id="程序完整代码："><a href="#程序完整代码：" class="headerlink" title="程序完整代码："></a>程序完整代码：</h3><p>//diy_in.h<br>char * s_gets( char * p, int n )//自定义函数的定义<br>{<br>  char * ret_val;<br>  char *find;</p>
<p>  ret_val = fgets( p, n , stdin );<br>  if(ret_val)<br>  {<br>    find = strchr( p, ‘\n’); //查找换行符的内存地址<br>    if (find)                //如果地址不是NULL<br>      *find = ‘\0’;       //将换行符换成空字符<br>    else<br>    while( getchar() != ‘\n’)<br>      continue;   //处理输入行中剩下的字符<br>   }<br>   return ret_val; //返回的是当前字符串的地址。<br>}</p>
<p>//main.c<br>#include&lt;stdio.h&gt;<br>#include&lt;string.h&gt;<br>#include”diy_in.h”<br>#define LEN 20</p>
<p>struct book<br>{<br>  char name[LEN];<br>  char author[LEN];<br>  float value;<br>};</p>
<p>int main ( void )<br>{<br>  int flag = 1;<br>  int n = 0, m = 0, i = 0, l = 0;<br>  char filename[LEN];<br>  char filename_quality[LEN+2];<br>  int quality[1];<br>  FILE * fp;<br>  FILE * fpn;<br>  struct book bookn[LEN];</p>
<p>  printf(“将图书信息保存到那个文件？（包含文件后缀和文件路径）”);<br>  s_gets(filename,LEN);<br>  fp  = fopen( filename,”a+”);<br>  while ( fp == NULL )<br>    {<br>      printf(“文件名不合法或路径错误或无操作权限，请重新输入：”,filename);<br>      s_gets(filename,LEN);<br>      fp = fopen( filename,”a+”) ;<br>    }<br>    fclose(fp);<br>  while( filename[m] != ‘\0’)<br>  {<br>    filename_quality[m] = filename[m];<br>    m++;<br>  }<br>  if ( fp != NULL )<br>  {</p>
<pre><code>//创建第二个文件，用于保存书本数量
m = strlen(filename) - 4;
filename\_quality\[m+5\] = filename\[m+3\];
filename\_quality\[m+4\] = filename\[m+2\];
filename\_quality\[m+3\] = filename\[m+1\];
filename\_quality\[m+2\] = filename\[m\];
filename\_quality\[m\]   = &apos;m&apos;;
filename\_quality\[m+1\] = &apos;n&apos;;
fpn = fopen ( filename\_quality,&quot;r&quot;);
if( fpn == NULL )//如果该文件不存在，则创建一个 
{
  fpn = fopen( filename\_quality,&quot;w&quot;);
  quality\[0\]=0;
}
fseek(fpn,9L,SEEK\_SET);//一个中文两个字节 
fscanf( fpn, &quot;%d&quot;, &amp;quality\[0\]);
n = quality\[0\];
fclose(fpn);</code></pre><p>  } </p>
<p>  fp = fopen( filename,”a+”);<br>  while( flag == 1 )<br>  {<br>  fprintf( fp, “【第%d本书】”,n+1 );<br>    printf(“请输入第%d本书的名字:”, n+1 );<br>    s_gets(bookn[n].name,LEN);<br>  fprintf( fp, “书名：%-20s”,bookn[n].name);<br>    printf(“请输入第%d本书的作者:”, n+1 );<br>    s_gets(bookn[n].author,LEN);<br>  fprintf( fp, “作者：%-20s”,bookn[n].author);<br>    printf(“请输入第%d本书的价钱:”, n+1 );<br>    scanf(“%f”,&amp;bookn[n].value);<br>  fprintf( fp, “价格：%-7.2f\n”,bookn[n].value);</p>
<pre><code>printf(&quot;已经成功录入%d本书的信息\\n&quot;,n+1);
printf(&quot;输入任意字符继续添加图书，输入0保存退出：&quot;); 
scanf(&quot;%d&quot;,&amp;flag);
while( getchar() != &apos;\\n&apos;)
  continue;
if( flag != 0)
{
  n++;
  l++;
}</code></pre><p>  }<br>  fclose(fp);<br>  fpn = fopen ( filename_quality,”w”);<br>  fprintf( fpn, “书本数量:%d”, n+1 );<br>  fclose(fpn); </p>
<p>  printf(“本次，共成功录入%d本书，总数%d已经保存到：%s”, l+1, n+1, filename_quality);</p>
<p>  return 0;<br>}</p>
<h3 id="程序演示："><a href="#程序演示：" class="headerlink" title="程序演示："></a>程序演示：</h3><p>[video width=”1920” height=”1080” mp4=”<a href="https://scanf.top/wp-content/uploads/2019/10/i4AirPlayer-1.mp4&quot;\]\[/video\]">https://scanf.top/wp-content/uploads/2019/10/i4AirPlayer-1.mp4&quot;\]\[/video\]</a></p>
]]></content>
      <categories>
        <category>其他</category>
        <category>编程练习</category>
      </categories>
      <tags>
        <tag>C/C++练习</tag>
        <tag>文件</tag>
        <tag>结构</tag>
      </tags>
  </entry>
  <entry>
    <title>教学实习编程必做题一：利用公式求π的值</title>
    <url>/archives/8e104a6f.html</url>
    <content><![CDATA[<p>编程要求：利用公式π/4=1-1/3+1/5-1/7+……求π的近似值，直到最后一项的绝对值小于10-6为止。</p>
<h3 id="代码部分："><a href="#代码部分：" class="headerlink" title="代码部分："></a>代码部分：</h3><p>//第一题，利用公式求pi的近似值<br>#include &lt;stdio.h&gt;<br>#include &lt;math.h&gt;</p>
<p>int main ( void )<br>{<br>  double pi;//要求的值<br>  double an;//通项表达式<br>  double sn = 0;//全n项和<br>  double an_av = 1.0;//an的绝对值<br>  int n;<br>  for( n = 1; an_av &gt;= 1e-6; n++ ) //求an的前n项和，直到an的绝对值小于 1e-6<br>  {</p>
<pre><code>an = pow(-1,n+1) / (2\*n-1);

if( an &lt; 0) //求an的绝对值为an\_av 
{
  an\_av = -an;
}

sn = sn + an; </code></pre><p>  }<br>  printf(“最终n=%d\n”, n);<br>  pi = sn * 4;<br>  printf(“pi=%lf”, pi);</p>
<p>  return 0;<br>}</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>观察可知1-1/3+1/5-1/7+……的通项表达式为：an=(-1)^(n+1)/(2n+1) 用for循环累加前n项和sn，直到an小于10^-6结束。 结果 π = sn * 4</p>
]]></content>
      <categories>
        <category>其他</category>
        <category>编程练习</category>
      </categories>
      <tags>
        <tag>C/C++练习</tag>
        <tag>教学实习编程必做题，for</tag>
      </tags>
  </entry>
  <entry>
    <title>教学实习编程必做题三：  打印螺旋矩阵</title>
    <url>/archives/392d3f64.html</url>
    <content><![CDATA[<p>题目描述：键盘输入整数n（3&lt;=n&lt;=10）,编写函数输出n阶螺旋矩阵。 比如，若n=3，则输出： <img src="https://scanf.top/wp-content/uploads/2019/09/2.png" alt="">     若n=4，则输出： <img src="https://scanf.top/wp-content/uploads/2019/09/3.png" alt="">        </p>
<h3 id="代码部分："><a href="#代码部分：" class="headerlink" title="代码部分："></a>代码部分：</h3><p>//第三题，打印n阶螺旋矩阵</p>
<p>#include &lt;stdio.h&gt;<br>void print(int N);<br>int main ( void )<br>{<br>  int N;</p>
<p>  printf(“输入矩阵阶数：”);<br>  scanf(“%d”,&amp;N);<br>  print(N);</p>
<p>  return 0;<br>}<br>void print(int N)<br>{<br>  int m,n,p,q,r,s,num=1;<br>  int a[10][10]={0};</p>
<p>  //一共有N/2或者N/2 + 1圈，每圈四面边框<br>  for( n = 0; n &lt; (float)N/2; n++ )//N转换为flaot，应对矩阵阶数为奇数的情况<br>  {<br>    //上边框<br>    for( p = n; p &lt;= N-n-1; p++)//N-n-1是当前边框中最后一个数字的数组下标<br>    {<br>      a[n][p] = num++;<br>     } </p>
<pre><code>//右边框 
for( q = n+1; q &lt;= N-n-2; q++)//N-n-2是当前边框中最后一个数字的数组下标
{
  a\[q\]\[N-n-1\] = num++;
}

//下边框
for( r = N-n-1; r &gt;= n+1; r-- )//N-n-1是当前边框中第一个数字的下标
{
  a\[N-n-1\]\[r\] = num++;
 } 

//左边框
for( s = N-n-1; s &gt;= n+1; s-- )//N-n-1是当前边框中第一个数字的下标
{
  a\[s\]\[n\] = num++;
 } </code></pre><p>  }<br>  //打印矩阵<br>  for( n = 0; n &lt; N; n++ )<br>  {<br>    for( m = 0; m &lt; N; m++ )<br>    {<br>      printf(“%3d “,a[n][m]);<br>    }<br>    printf(“\n”);<br>   }<br>}</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>将N阶螺旋矩阵划分为n圈，每圈分为上、右、下和左四个边框，每个边框中的元素按照一定的顺序写入一个二维数组中，像这样的边框一共有N/2圈或N/2 + 1圈。</p>
<h4 id="边框划分如下图："><a href="#边框划分如下图：" class="headerlink" title="边框划分如下图："></a>边框划分如下图：</h4><p><img src="https://scanf.top/wp-content/uploads/2019/09/fullsizerender2.jpg" alt=""></p>
<h4 id="四个边框写入方法如下："><a href="#四个边框写入方法如下：" class="headerlink" title="四个边框写入方法如下："></a>四个边框写入方法如下：</h4><p>①：在将上边框写入二维数组时，二维数组的横标不变，为n，代表当前行数（行序从0开始），二维数组的纵标从n开始一直递增到最后一个元素的纵标N-n-1；</p>
<p>②：在将右边框写入二维数组时，二维数组的纵标不变，为N-n-1，二维数组的横标从n+1一直递增到N-n-2;</p>
<p>③：在将下边框写入二维数组时，二维数组的横标不变，为N-n-1，二维数组的纵标从N-n-1一直递减到n+1；</p>
<p>④：在将左边框写入二维数组时，二维数组的纵标不变，为n，二维数组的横标从N-n-1一直递减到n+1；</p>
<p>最后遍历数组，每行打印N个元素，即每打印N个元素打印一个换行符。</p>
]]></content>
      <categories>
        <category>其他</category>
        <category>编程练习</category>
      </categories>
      <tags>
        <tag>C/C++练习</tag>
        <tag>二维数组</tag>
        <tag>螺旋矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>教学实习编程必做题二： 输出三角形的九九乘法口诀表</title>
    <url>/archives/8e3b9ebd.html</url>
    <content><![CDATA[<p>编程要求：输出三角形的九九乘法口诀表，如图所示：</p>
<p><img src="https://scanf.top/wp-content/uploads/2019/09/1.png" alt=""></p>
<h3 id="代码部分："><a href="#代码部分：" class="headerlink" title="代码部分："></a>代码部分：</h3><p>//第二题，输出三角形的九九乘法口诀表<br>//整体实现思路：采用嵌套for循环<br>//一行一行，一句一句打印，从上到下，从左到右<br>#include&lt;stdio.h&gt;</p>
<p>int main ( void )<br>{<br>  int row,first,second,third;//first被乘数，second乘数，third乘积 </p>
<p>  for ( row = 1; row &lt;= 9; row++ )//循环一次打印一行内容<br>  {<br>    for ( first = 1; first &lt;= row; first++ )//循环一次打印一句<br>    {<br>      second = row;// 乘数等于当前行数<br>      third = first * second;<br>      printf(“%d*%d=%2d  “,first,second,third);</p>
<pre><code>}
printf(&quot;\\n&quot;);//行末换行 </code></pre><p>   } </p>
<p>  return 0;<br>}</p>
<h3 id="实现思路："><a href="#实现思路：" class="headerlink" title="实现思路："></a>实现思路：</h3><p>整体思路：采用嵌套for循环，一行一行，一句一句打印，从上到下，从左到右 需要说明的是：first被乘数，second乘数，third乘积 更多解释请看代码后的注释。</p>
]]></content>
      <categories>
        <category>其他</category>
        <category>编程练习</category>
      </categories>
      <tags>
        <tag>C/C++练习</tag>
        <tag>嵌套for循环</tag>
        <tag>教学实习编程必做题</tag>
      </tags>
  </entry>
  <entry>
    <title>编程练习4.8：有关*修饰符在printf中的应用</title>
    <url>/archives/8c5f657a.html</url>
    <content><![CDATA[<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>编写一个程序，提供用户输入名和姓。并按以下要求打印输出： a.打印名和姓，包括双引号。 b.在宽度为20的字段的右端打印名和姓，包括双引号。 c.在宽度为20的字段的左端打印名和姓，包括双引号。 d.在此姓名宽度宽3的字段中打印名和姓。  </p>
<h3 id="考察点分析："><a href="#考察点分析：" class="headerlink" title="考察点分析："></a>考察点分析：</h3><p>a.printf中打印相关字符。 b、c、d.*修饰符在printf中的使用。  </p>
<h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><p>#include&lt;stdio.h&gt;<br>#include&lt;string.h&gt;//包含strlen()函数</p>
<p>int main (void)<br>{<br>    char first_name[40];<br>    char family_name[40];<br>    int x=0,y=0; </p>
<pre><code>printf(&quot;Enter your first name please:&quot;);
scanf(&quot;%s&quot;,first\_name);
printf(&quot;Enter your family name please:&quot;);
scanf(&quot;%s&quot;,family\_name);

x=strlen(first\_name);//x为first\_name的长度 
y=strlen(family\_name);//y为family\_name的长度

printf(&quot;\\&quot;%s,%s\\&quot;\\n&quot;,first\_name,family\_name);
printf(&quot;\\&quot;%\*s,%s\\&quot;\\n&quot;,20-y-3,first\_name,family\_name);
printf(&quot;\\&quot;%s,%-\*s\\&quot;\\n&quot;,first\_name,20-x-3,family\_name); 
printf(&quot;\\&quot;%\*s,%s\\&quot;&quot;,x+3,first\_name,family\_name);

return 0;</code></pre><p>}</p>
]]></content>
      <categories>
        <category>其他</category>
        <category>编程练习</category>
      </categories>
      <tags>
        <tag>C/C++练习</tag>
        <tag>习题</tag>
      </tags>
  </entry>
  <entry>
    <title>请分别输入响铃次数和响铃间隔时间</title>
    <url>/archives/fd75f50c.html</url>
    <content><![CDATA[<p>#include&lt;stdio.h&gt;<br>#include &lt;unistd.h&gt;//包含sleep函数 </p>
<p>int diy_bell(int times,int interrupt); //times表示响铃次数，interrupt表示间歇时间<br>int main( void )<br>{<br>    int times,interrupt;</p>
<pre><code>printf(&quot;请分别输入响铃次数和响铃间隔时间：&quot;);
scanf(&quot;%d %d&quot;,&amp;times,&amp;interrupt); 
diy\_bell(times,interrupt);//调用了diy\_bell.h里所声明的函数 
printf(&quot;完毕&quot;); 

getchar();
getchar();
return 0;</code></pre><p> }<br>int diy_bell(int times,int interrupt)<br>{<br>    int order=1;<br>    while(times– != 0){<br>        sleep(interrupt);<br>        printf(“第%d次\a “,order++);<br>    }</p>
<pre><code>return 0;</code></pre><p>}</p>
]]></content>
      <categories>
        <category>其他</category>
        <category>编程练习</category>
      </categories>
      <tags>
        <tag>C/C++练习</tag>
        <tag>蜂鸣器</tag>
      </tags>
  </entry>
  <entry>
    <title>请分别输入响铃次数和响铃间隔时间（模块化编程版）</title>
    <url>/archives/aad9fe49.html</url>
    <content><![CDATA[<p><strong>main.c</strong></p>
<p>#include&lt;stdio.h&gt;<br>#include”diy_bell.h”</p>
<p>int main( void )<br>{<br>    int times,interrupt;//times表示响铃次数，interrupt表示间歇时间</p>
<pre><code>printf(&quot;请分别输入响铃次数和响铃间隔时间：&quot;);
scanf(&quot;%d %d&quot;,&amp;times,&amp;interrupt); 
diy\_bell(times,interrupt);//调用了diy\_bell.h里所声明的函数 
printf(&quot;完毕&quot;); 

getchar();
getchar();
return 0;</code></pre><p> }</p>
<p>  <strong>diy_bell.h</strong></p>
<p>int diy_bell(int times,int interrupt);</p>
<p>  <strong>diy_bell.c</strong></p>
<p>#include &lt;unistd.h&gt;//包含sleep函数<br>#include “diy_bell.h”//包含diy_bell函数的声明 </p>
<p>int diy_bell(int times,int interrupt)<br>{<br>    int order=1;<br>    while(times– != 0){<br>                sleep(interrupt);<br>        printf(“第%d次\a “,order++);<br>    }</p>
<pre><code>return 0;</code></pre><p>}</p>
<p><strong>输入输出演示：</strong></p>
<p><img src="https://www.scanf.top/wp-content/uploads/2019/08/QQ%E6%88%AA%E5%9B%BE20190807212840.png" alt=""></p>
<p>其中第1次和第2次……的出现，都伴随着蜂鸣声</p>
]]></content>
      <categories>
        <category>其他</category>
        <category>编程练习</category>
      </categories>
      <tags>
        <tag>C/C++练习</tag>
        <tag>蜂鸣器</tag>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title>递归的优缺点</title>
    <url>/archives/ecfdb445.html</url>
    <content><![CDATA[<p>递归既有有点也有缺点。优点是递归为某些编程问题提供了最简单的解决方案。缺点是一些递归算法会快速消耗计算机的内存资源，很可能导致程序崩溃，并且递归不方便阅读和维护。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>递归</category>
      </categories>
      <tags>
        <tag>C/C++笔记</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>顺序表中基本操作的实现</title>
    <url>/archives/62da627e.html</url>
    <content><![CDATA[<h1 id="顺序表的存储结构"><a href="#顺序表的存储结构" class="headerlink" title="顺序表的存储结构"></a>顺序表的存储结构</h1><p>#define MAXSIZE 100<br>typedef struct<br>{<br>  ElemType *elem;//存储空间的基地址<br>  int length;//当前长度<br>}SqList;//顺序表的结构类型为SqList</p>
<h2 id="一、初始化"><a href="#一、初始化" class="headerlink" title="一、初始化"></a><strong>一、初始化</strong></h2><blockquote>
<p>顺序表的初始化操作就是构造一个空的顺序表。</p>
</blockquote>
<h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="[算法步骤]"></a><strong>[算法步骤]</strong></h4><p>① 为顺序表L动态分配一个预定义大小的数组空间，使elem指向这段空间基地址。 ② 将表的当前长度设为0。</p>
<h4 id="算法描述"><a href="#算法描述" class="headerlink" title="[算法描述]"></a><strong>[算法描述]</strong></h4><p>Status InitList ( SqList &amp;L )<br>{<br>  L.elem = new ElemType[MAXSIZE];//为顺序表分配一个大小为MAXSIZE的数组空间<br>  if ( !L.elem ) exit(OVERFLOW);//存储分配失败退出<br>  L.length = 0;<br>  return OK;<br>}</p>
<h4 id="DEMO"><a href="#DEMO" class="headerlink" title="[DEMO]"></a><strong>[DEMO]</strong></h4><p>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#define MAXSIZE 100<br>#define OVERFLOW -1<br>#define OK 0</p>
<p>typedef int Status;<br>typedef struct<br>{<br>  int *elem;//存储空间的基地址<br>  int length;//当前长度<br>}SqList;<br>Status InitList ( SqList &amp;L );<br>int main ( void )<br>{<br>  SqList L;</p>
<p>  if (InitList(L) == OK ) printf(“成功构造了一个空的顺序表，该顺序表的基地址是：%X”,L.elem);<br>  else printf(“存储分配失败”);</p>
<p>  return 0;<br>}<br>Status InitList ( SqList &amp;L )<br>{<br>  L.elem = new int[MAXSIZE];<br>  if ( !L.elem ) exit(OVERFLOW);<br>  L.length = 0;<br>  return OK;<br>}</p>
<h2 id="二、取值"><a href="#二、取值" class="headerlink" title="二、取值"></a>二、取值</h2><blockquote>
<p>取值操作是根据指定的位置序号i，获取顺序表中第i个数据元素的值。</p>
</blockquote>
<h4 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="[算法步骤]"></a><strong>[算法步骤]</strong></h4><p>① 判断指定位置序号i值是否合理（ 1 ≤ i ≤ L.length ）， 若不合理，返回ERROR。 ② 若i值合理，则将第i个数据元素L.elem[i-1]赋给参数e，通过e返回第i个数据元素的值 注：参数e为引用，实参和形参值的传递是双向的，即形参值的改变会引起实参值的改变。</p>
<h4 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="[算法描述]"></a><strong>[算法描述]</strong></h4><p>Status GetElem ( SqList &amp;L, int i, ElemType &amp;e )<br>{<br>  if ( i &lt; 1 || i &gt; L.length ) return ERROR; //判断i值是否合理<br>  e = L.elem[i-1];//将第i个元素传给e</p>
<p>  return OK;<br>}</p>
<h4 id="DEMO-1"><a href="#DEMO-1" class="headerlink" title="[DEMO]"></a><strong>[DEMO]</strong></h4><p>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#define MAXSIZE 100<br>#define OVERFLOW -1<br>#define OK 0<br>#define ERROR 1</p>
<p>typedef int Status;<br>typedef struct<br>{<br>  int *elem;//存储空间的基地址<br>  int length;//当前长度<br>}SqList;</p>
<p>Status InitList ( SqList &amp;L );//初始化顺序表函数的声明<br>Status GetElem ( SqList &amp;L, int i, int &amp;e );//顺序表取值函数的声明 </p>
<p>int main ( void )<br>{<br>  int GetStaus,i,e;<br>  SqList L;</p>
<p>  if ( InitList(L) == OVERFLOW )<br>  {<br>    printf(“存储分配失败”);<br>  }<br>  else<br>  {<br>    L.elem[0] = 1;<br>    L.elem[1] = 3;<br>    L.elem[2] = 2;<br>    L.elem[3] = 5;<br>    L.elem[4] = 4;<br>    L.length = 5;<br>    printf(“请输入数据元素的序号：”);<br>    scanf(“%d”,&amp;i);<br>    GetStaus = GetElem(L,i,e);<br>  }<br>  if ( GetStaus == ERROR ) printf(“i值不合理”);<br>  else printf(“第%d个元素是：%d”,i,e);</p>
<p>  return 0;<br>}<br>Status InitList ( SqList &amp;L )//初始化顺序表函数的定义<br>{<br>  L.elem = new int[MAXSIZE];<br>  if ( !L.elem ) exit(OVERFLOW);<br>  L.length = 0;<br>  return OK;<br>}<br>Status GetElem ( SqList &amp;L, int i, int &amp;e )//顺序表取值函数的定义<br>{<br>  if ( i &lt; 1 || i &gt; L.length ) return ERROR;<br>  e = L.elem[i-1];</p>
<p>  return OK;<br>}</p>
<h2 id="三、查找"><a href="#三、查找" class="headerlink" title="三、查找"></a>三、查找</h2><blockquote>
<p>查找操作是根据指定的元素值e，查找顺序表中第1个与e相等的元素。若查找成功，则返回该元素在表中的位置序号；查找失败返回0。</p>
</blockquote>
<h4 id="算法步骤-2"><a href="#算法步骤-2" class="headerlink" title="[算法步骤]"></a><strong>[算法步骤]</strong></h4><p>① 从第一元素起，依次和e相比较，若找到与e相等的元素L.elem[i]，则查找成功，返回该元素的序号i+1。 ② 若查遍整个顺序表都没有找到，则查找失败，返回0。</p>
<h4 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="[算法描述]"></a><strong>[算法描述]</strong></h4><p>int LocateElem ( SqList L, ElemType e )<br>{<br>  for ( i = 0; i &lt; L.length; i++ )<br>    if ( L.elem[i] == e ) return i+1;</p>
<p>   return 0;<br>}</p>
<h4 id="DEMO-2"><a href="#DEMO-2" class="headerlink" title="[DEMO]"></a><strong>[DEMO]</strong></h4><p>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#define MAXSIZE 100<br>#define OVERFLOW -1<br>#define OK 0</p>
<p>typedef int Status;<br>typedef struct<br>{<br>  int *elem;//存储空间的基地址<br>  int length;//当前长度<br>}SqList;<br>Status InitList ( SqList &amp;L );<br>int LocateElem ( SqList &amp;L, int e );<br>int main ( void )<br>{<br>  int e,locate;<br>  SqList L;</p>
<p>  if ( InitList(L) == OK )<br>  {<br>    L.elem[0] = 1;<br>    L.elem[1] = 3;<br>    L.elem[2] = 2;<br>    L.elem[3] = 5;<br>    L.elem[4] = 4;<br>    L.length = 5;<br>    printf(“你要找哪个数字的位置呀？”);<br>    scanf(“%d”,&amp;e);<br>    locate = LocateElem(L,e);<br>    if( locate != 0 )<br>    {<br>      printf(“你要找的数字%d的序号是：%d”,e,LocateElem(L,e));<br>    }<br>    else<br>    {<br>      printf(“查无此数”);<br>    }</p>
<p>  }<br>  else printf(“存储分配失败”);</p>
<p>  return 0;<br>}<br>Status InitList ( SqList &amp;L )<br>{<br>  L.elem = new int[MAXSIZE];<br>  if ( !L.elem ) exit(OVERFLOW);<br>  L.length = 0;<br>  return OK;<br>}<br>int LocateElem ( SqList &amp;L, int e )<br>{<br>  int i;<br>  for ( i = 0; i &lt; L.length; i++ )<br>    if ( L.elem[i] == e) return i+1;<br>  return 0;<br>}</p>
<h2 id="四、插入"><a href="#四、插入" class="headerlink" title="四、插入"></a>四、插入</h2><blockquote>
<p>线性表的插入操作是指在表的第i个位置插入一个新的数据元素e，使长度为n的线性表变成长度为n+1的线性表。</p>
</blockquote>
<h4 id="算法步骤-3"><a href="#算法步骤-3" class="headerlink" title="[算法步骤]"></a><strong>[算法步骤]</strong></h4><p>① 判断插入位置i是否合理（ 1 ≤ i ≤ n+1 ），若不合理则返回ERROR。 ② 判断顺序表的存储空间是否已满，若满则返回ERROR。 ③ 将第n个至第i个位置的元素依次向后移动一个位置，空出第i个位置，当i = n +1时无需移动。 ④ 将要插入的新元素e放入第i个位置。 ⑤ 表长加1。</p>
<h4 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="[算法描述]"></a><strong>[算法描述]</strong></h4><p>Status ListInsert ( SqList &amp;L, int i, ElemType e )<br>{<br>  if( (i &lt; 1) || (i &gt; L.length + 1) ) return ERROR;//i值不合理<br>  if ( L.length == MAXSIZE ) return ERROR;//存储空间已满<br>  for ( j = L.length - 1; j &gt;= i-1; j– )<br>    L.elem[j+1] = L.elem[j];//元素后移<br>  L.elem[i-1] = e;//插入新元素<br>  ++L.length;/表长加1</p>
<p>  return 0;<br>}</p>
<h4 id="DEMO-3"><a href="#DEMO-3" class="headerlink" title="[DEMO]"></a><strong>[DEMO]</strong></h4><p>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#define MAXSIZE 100<br>#define OVERFLOW -1<br>#define OK 0<br>#define ERROR 1</p>
<p>typedef int Status;<br>typedef struct<br>{<br>  int *elem;//存储空间的基地址<br>  int length;//当前长度<br>}SqList;<br>Status InitList ( SqList &amp;L );<br>Status ListInsert ( SqList &amp;L, int i, int e );<br>int main ( void )<br>{<br>  int e,i;<br>  SqList L;<br>  if (InitList(L) == OK )<br>  {<br>    L.elem[0] = 2;<br>    L.elem[1] = 4;<br>    L.elem[2] = 6;<br>    L.elem[3] = 8;<br>    L.elem[4] = 10;<br>    L.length = 5;<br>    printf(“存储分配成功,请输入需要插入的数字和位置：”);<br>    scanf(“%d%d”,&amp;e,&amp;i);<br>    if ( ListInsert(L,i,e) == ERROR ) printf(“插入位置不合法或者线性表已满”);<br>    else<br>    {<br>      printf(“插入前的线性表中的元素为：2  4  6  8  10\n”);<br>      printf(“插入后的线性表中的元素为：”);<br>      for ( i = 0; i &lt;= L.length-1; i++ )<br>      printf(“%-2d “,L.elem[i]);<br>    }<br>  }<br>  else printf(“存储分配失败”);</p>
<p>  return 0;<br>}<br>Status InitList ( SqList &amp;L )<br>{<br>  L.elem = new int[MAXSIZE];<br>  if ( !L.elem ) exit(OVERFLOW);<br>  L.length = 0;<br>  return OK;<br>}<br>Status ListInsert ( SqList &amp;L, int i, int e )<br>{<br>  int j;<br>  if ( (i &lt; 1) || (i &gt; L.length+1) ) return ERROR;<br>  if ( L.length == MAXSIZE ) return ERROR;<br>  if( i == L.length + 1 )<br>  {<br>    L.elem[i] = e;<br>  }<br>  else<br>  {<br>    for ( j = L.length -1; j &gt;= i-1; j– )<br>    L.elem[j+1] = L.elem[j];<br>  }</p>
<p>  L.elem[i-1] = e;<br>  ++L.length;</p>
<p>  return OK;<br>}</p>
<h2 id="五、删除"><a href="#五、删除" class="headerlink" title="五、删除"></a>五、删除</h2><blockquote>
<p>线性表的删除操作是指将表的第i个元素删去，将长度为n的线性表变成长度为n-1的线性表</p>
</blockquote>
<h4 id="算法步骤-4"><a href="#算法步骤-4" class="headerlink" title="[算法步骤]"></a><strong>[算法步骤]</strong></h4><p>① 判断删除位置i是否合法（ 1 ≤ i ≤ L.length ），若不合法则返回ERROR。 ② 将第i+1个至第L.length个的元素依次向前移动一个位置，当i=L.length时无需移动。 ③ 表长+1。</p>
<h4 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="[算法描述]"></a><strong>[算法描述]</strong></h4><p>Status ListDelete ( SqList &amp;L, int i )<br>{<br>  if ( (i &lt; 1) || (i &gt; L.length) ) return ERROR;//i值不合法<br>  for ( j = i; j &lt;= L.length -1; j– )<br>    L.elem[j-1] = L.elem[j];//被删元素之后d额元素前移<br>  –L.length;//表长减一</p>
<p>  return 0;<br>}</p>
<p><strong>[DEMO]</strong></p>
<p>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#define MAXSIZE 100<br>#define OVERFLOW -1<br>#define OK 0<br>#define ERROR 1 </p>
<p>typedef int Status;<br>typedef struct<br>{<br>  int *elem;//存储空间的基地址<br>  int length;//当前长度<br>}SqList;<br>Status InitList ( SqList &amp;L );<br>Status ListDelete ( SqList &amp;L, int i );<br>int main ( void )<br>{<br>  int i;<br>  SqList L;<br>  if (InitList(L) == OK )<br>  {<br>    L.elem[0] = 2;<br>    L.elem[1] = 4;<br>    L.elem[2] = 6;<br>    L.elem[3] = 8;<br>    L.elem[4] = 10;<br>    L.length = 5;<br>    printf(“线性表初始化成功,请输入被删除元素的位置：”);<br>    scanf(“%d”,&amp;i);<br>    if ( ListDelete(L,i) == ERROR ) printf(“位置不合法”);<br>    else<br>    {<br>      printf(“的线性表中的元素为：2  4  6  8  10\n”);<br>      printf(“插入后的线性表中的元素为：”);<br>      for ( i = 0; i &lt;= L.length-1; i++ )<br>      printf(“%-2d “,L.elem[i]);<br>    }<br>  }<br>  else printf(“存储分配失败”);</p>
<p>  return 0;<br>}<br>Status InitList ( SqList &amp;L )<br>{<br>  L.elem = new int[MAXSIZE];<br>  if ( !L.elem ) exit(OVERFLOW);<br>  L.length = 0;<br>  return OK;<br>}<br>Status ListDelete ( SqList &amp;L, int i )<br>{<br>  int j;</p>
<p>  if ( (i &lt; 1) || (i &gt; L.length) ) return ERROR;<br>  for ( j = i; j &lt;= L.length -1; j++ )<br>    L.elem[j-1] = L.elem[j];<br>  –L.length;</p>
<p>  return OK;<br>}</p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>表</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>顺序表</tag>
      </tags>
  </entry>
  <entry>
    <title>顺序表的基本操作</title>
    <url>/archives/85a7966c.html</url>
    <content><![CDATA[<h1 id="一、线性表"><a href="#一、线性表" class="headerlink" title="一、线性表"></a>一、线性表</h1><h2 id="1-1-线性表的定义"><a href="#1-1-线性表的定义" class="headerlink" title="1.1 线性表的定义"></a>1.1 线性表的定义</h2><ul>
<li>由n（n≥0）个数据特性相同的元素构成有限序列成为线性表。</li>
<li>n定义为线性表的表长，当n=0时成为空表。</li>
</ul>
<h2 id="1-2-线性表的顺序表示和实现"><a href="#1-2-线性表的顺序表示和实现" class="headerlink" title="1.2 线性表的顺序表示和实现"></a>1.2 线性表的顺序表示和实现</h2><h3 id="1-2-1-顺序表的相关概念"><a href="#1-2-1-顺序表的相关概念" class="headerlink" title="1.2.1 顺序表的相关概念"></a>1.2.1 顺序表的相关概念</h3><p><strong>定义</strong>：用同一组<strong>地址连续</strong>的存储单元依次存储线性表的数据元素。是一种<strong>随机存储结构</strong>。（可以直接读取某个元素） <strong>特点</strong>：逻辑上相邻的数据元素，物理次序也是相邻的。</p>
<h3 id="1-2-2-顺序表类"><a href="#1-2-2-顺序表类" class="headerlink" title="1.2.2 顺序表类"></a>1.2.2 顺序表类</h3><pre><code>public class SqList{
    private int MAXSIZE;//顺序表可能达到的最大长度
    private int length;//当前长度
    private ElemType[] elem;//元素存储空间

    public SqList(int MAXSIZE){..}//初始化，构造一个最大长度可能达到MAXSIZE的空的顺序表
    public int GetElem(int n) throws RuntimeException{..return num;}//取值，返回第i个元素的值
    public int LocateElem(int num) throws RuntimeException{..return n;}//查找，返回第一个值为num的元素的位置序号
    public void ListInsert(int n, int num) throws RuntimeException{..return Status;}//插入，第n个位置上插入num值
    public void ListDelete(int n){..return Status;}//删除，删除第n个元素
}</code></pre><h3 id="1-2-3-顺序表的基本操作"><a href="#1-2-3-顺序表的基本操作" class="headerlink" title="1.2.3 顺序表的基本操作"></a>1.2.3 顺序表的基本操作</h3><h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1 初始化"></a>1 初始化</h4><p>顺序表的初始化就是构造一个空的顺序表。 【算法步骤】</p>
<ol>
<li>设置顺序表的最大可能达到的长度。</li>
<li>将表的当前长度设为0；</li>
<li>为顺序表分配一个长度为MAXSIZE的数组。</li>
</ol>
<p>【算法实现】</p>
<pre><code>public SqList(int MAXSIZE){
    this.MAXSIZE = MAXSIZE;
    this.length = 0;
    this.elem = new int[MAXSIZE];
}//初始化，构造一个最大长度可能达到MAXSIZE的空的顺序表</code></pre><h4 id="2-取值"><a href="#2-取值" class="headerlink" title="2 取值"></a>2 取值</h4><p>根据指定的位置序号n，获取表中第n个数据元素的值。 【算法步骤】</p>
<ol>
<li>判断n值是否合理（1 ≤ n ≤ this.length）,若不合理，则返回错误代码-1；</li>
<li>若n值合理，则返回第n个数据元素的值。</li>
</ol>
<p>【算法实现】</p>
<pre><code>public int GetElem(int n) throws RuntimeException {
    if (n&gt;= 1 &amp;&amp; n &lt;= this.length) {
        return this.elem[n-1];//位置序号合理，返回第n个元素的值
    }
    else {
        throw new RuntimeException(&quot;指定的位置不合理&quot;);//抛出异常
    }       
}//取值，返回第i个元素的值</code></pre><h4 id="3-查找"><a href="#3-查找" class="headerlink" title="3 查找"></a>3 查找</h4><p>根据指定的值num，在线性表中查找第一个与num相等的元素，若查找成功，则返回该元素的位置，查找失败，抛出异常； 【算法步骤】</p>
<ol>
<li><p>从顺序表的第一个元素开始，依次和num进行比较，若找到与e相等的元素this.elem[i]，则查找成功，返回该元素的序号i+1；</p>
</li>
<li><p>若找遍整个顺序表都没有找到，则查找失败，抛出异常；</p>
</li>
</ol>
<p>【算法实现】</p>
<pre><code>public int LocateElem(int num) throws RuntimeException{
    for (int i = 0; i &lt; this.length; i++) {
        if (this.elem[i] == num) {return i+1;}
    }
    throw new RuntimeException(&quot;查找失败&quot;);
}//查找，返回第一个值为num的元素的位置序号</code></pre><h4 id="4-插入"><a href="#4-插入" class="headerlink" title="4 插入"></a>4 插入</h4><p>在表的第n个位置插入新的数据元素num，使表长为n的顺序表变为n+1； 【算法步骤】</p>
<ol>
<li><p>判断顺序表是否已满（已满的条件 MAXSIZE&lt;=this.length）,如果已满，抛出异常，如果未满执行以下操作：</p>
</li>
<li><p>判断插入的位置是否合理（合理范围1 ≤ n ≤ this.length），如果n值不合理，抛出异常，如果n值合理执行以下操作：</p>
</li>
<li><p>将最后一个元素至第n个元素依次向后移动一个位置，空出第n个位置</p>
</li>
<li><p>将元素num放到第n个位置上。</p>
</li>
<li><p>this.length++;</p>
</li>
</ol>
<p>【算法实现】</p>
<pre><code>public void ListInsert(int n, int num) throws RuntimeException{
    if (MAXSIZE &gt; this.length) {
        if (n&gt;= 1 &amp;&amp; n &lt;= this.length) {
            for (int i = this.length; i &gt;= n; i--) {
                this.elem[i] = this.elem[i-1];
            }
            this.elem[n-1] = num;
            this.length++;
        } else {
            throw new RuntimeException(&quot;插入的位置不合理&quot;);
        }
    } else {
        throw new RuntimeException(&quot;顺序表空间不足&quot;);
    }
}//插入，第n个位置上插入num值</code></pre><h4 id="5-删除"><a href="#5-删除" class="headerlink" title="5 删除"></a>5 删除</h4><p>将表中第n个元素删去，将长度为this.length的顺序表变为长度为this.length-1的顺序表。 【算法步骤】</p>
<ol>
<li><p>判断删除元素的位置n是否合理（合理范围1 ≤ n ≤ this.length），如果不合理抛出异常，如果合理，则执行下面操作：</p>
</li>
<li><p>将第n+1至第this.length个元素依次向前移动一个位置。</p>
</li>
<li><p>this.length–;</p>
</li>
</ol>
<p>【算法实现】</p>
<pre><code>public void ListDelete(int n){
        if (n&gt;= 1 &amp;&amp; n &lt;= this.length) {
            for (int i = n+1; i &lt;= this.length; i++) {
                this.elem[i-2] = this.elem[i-1];
            }
            this.length--;
        } else {
            throw new RuntimeException(&quot;删除元素的位置不合理&quot;);
        }
    }//删除，删除第n个元素</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
        <category>表</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>初识“编译器”及其工作原理</title>
    <url>/archives/178506b4.html</url>
    <content><![CDATA[<h2 id="1、编译器是什么？"><a href="#1、编译器是什么？" class="headerlink" title="1、编译器是什么？"></a>1、编译器是什么？</h2><p><strong>编译器</strong>（compiler①）是一个程序，能把高级计算机语言翻译成计算机能理解的机器语言指令集。 <strong>反编译器</strong>用来从由高级语言生成的低级语言代码重新生成高级语言代码，简单地说就是将已编译好的编程语言还原到未编译的状态。</p>
<blockquote>
<p>“高级计算机语言便于人编写，阅读交流，维护。机器语言是计算机能直接解读、运行的。编译器将汇编或高级计算机语言源程序（Source program）作为输入，翻译成目标语言（Target language）机器代码的等价程序。源代码一般为高级语言 (High-level language)， 如Pascal、C、C++、Java、汉语编程等或汇编语言，而目标则是机器语言的目标代码（Object code），有时也称作机器代码（Machine code）。”——引用自百度百科《<a href="https://baike.baidu.com/item/%E7%BC%96%E8%AF%91%E5%99%A8/8853067?fr=aladdin" target="_blank" rel="noopener external nofollow noreferrer">编译器</a>》</p>
</blockquote>
<h2 id="2、编译器的工作原理。"><a href="#2、编译器的工作原理。" class="headerlink" title="2、编译器的工作原理。"></a>2、编译器的工作原理。</h2><p>编译是一个翻译的过程，该过程将源代码（通常为高阶语言）翻译成能直接被计算机或虚拟机执行的目标代码（通常为低阶语言或机器语言）。 一个现代编译器的主要工作流程：源代码 (source code) → 预处理器 (preprocessor) → 编译器 (compiler) → 目标代码 (object code) → 链接器 (Linker) → 可执行程序 (executables②) 编译器的工作过程：<a href="http://www.ruanyifeng.com/blog/2014/11/compiler.html" target="_blank" rel="noopener external nofollow noreferrer">http://www.ruanyifeng.com/blog/2014/11/compiler.html</a></p>
<blockquote>
<p>涉及的部分英语词汇： ①compiler/kəmˈpaɪlər/编译器 ②executables/ɪɡˈzekjətəbl]/可执行程序</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机专业知识</category>
        <category>编译</category>
      </categories>
      <tags>
        <tag>C/C++笔记</tag>
        <tag>反编译器</tag>
        <tag>编译器</tag>
      </tags>
  </entry>
</search>
